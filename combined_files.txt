Файл main.py:

"""
Модуль для создания базы данных, генерации данных и создания дампа.

Импорты:
    - Импортируются все необходимые модели и генераторы данных из других модулей.

Функции:
    - create_source_db_and_tables: Создает базу данных и таблицы.
    - generate_and_insert_data: Генерирует и вставляет данные в базу данных.
    - create_dump: Создает дамп базы данных и сохраняет его в файл.
"""

from lib.db import Database
from lib.orm import (
    Application, Users, Modification, Purchase, Checks, HWID, Operation, Subscription, Token, Version
)
from lib.data_generator import (
    generate_application_data, generate_user_data, generate_modification_data, generate_purchase_data, 
    generate_check_data, generate_hwid_data, generate_operation_data, generate_subscription_data, 
    generate_token_data, generate_version_data
)

def create_source_db_and_tables():
    """
    Создание базы данных 'source_db' и её таблиц.

    :return: Объект Database для созданной базы данных.
    """
    db_name = 'source_db'
    db = Database(db_name)

    # Создание таблиц для всех моделей
    Application.create_table(db)
    Modification.create_table(db)
    Users.create_table(db)
    Purchase.create_table(db)
    Checks.create_table(db)
    HWID.create_table(db)
    Operation.create_table(db)
    Subscription.create_table(db)
    Token.create_table(db)
    Version.create_table(db)

    # Создание таблиц many-to-many для Users после создания всех таблиц
    Users.create_many_to_many_tables(db)
    
    print(f"База данных '{db_name}' и таблицы успешно созданы.")
    return db

def generate_and_insert_data(db):
    """
    Генерация и вставка данных в базу данных.

    :param db: Объект Database для подключения к базе данных.
    """
    db.delete_all_data()
    print("Генерация данных...")

    # Генерация и вставка данных для модели Application
    apps = list(generate_application_data(10))
    for app in apps:
        app.save(db)
    app_ids = [app.app_id for app in Application.get_all(db)]
    print(f"Сгенерировано {len(app_ids)} приложений")

    # Генерация и вставка данных для модели Users
    users = list(generate_user_data(100, app_ids))
    for user in users:
        user.save(db)
    user_ids = [user.user_id for user in Users.get_all(db)]
    print(f"Сгенерировано {len(user_ids)} пользователей")

    # Генерация и вставка данных для модели Modification
    mods = list(generate_modification_data(50, app_ids))
    for mod in mods:
        mod.save(db)
    mod_ids = [mod.mod_id for mod in Modification.get_all(db)]
    print(f"Сгенерировано {len(mod_ids)} модификаций")

    # Генерация и вставка данных для модели Purchase
    purchases = list(generate_purchase_data(200, user_ids, mod_ids))
    for purchase in purchases:
        purchase.save(db)
    purchase_ids = [purchase.purchase_id for purchase in Purchase.get_all(db)]
    print(f"Сгенерировано {len(purchase_ids)} покупок")

    # Генерация и вставка данных для модели Checks
    checks = list(generate_check_data(200, purchase_ids))
    for chk in checks:
        chk.save(db)
    print(f"Сгенерировано 200 чеков")

    # Генерация и вставка данных для модели HWID
    hwids = list(generate_hwid_data(100, user_ids))
    for hw in hwids:
        hw.save(db)
    hwid_ids = [hw.hwid_id for hw in HWID.get_all(db)]
    print(f"Сгенерировано {len(hwid_ids)} HWID записей")

    # Генерация и вставка данных для модели Operation
    operations = list(generate_operation_data(300, user_ids))
    for operation in operations:
        operation.save(db)
    print(f"Сгенерировано {len(operations)} операций")
        
    # Генерация и вставка данных для модели Subscription
    subscriptions = list(generate_subscription_data(150, user_ids, mod_ids))
    for subscription in subscriptions:
        subscription.save(db)
    print(f"Сгенерировано {len(subscriptions)} подписок")
    
    # Генерация и вставка данных для модели Token
    tokens = list(generate_token_data(100, user_ids, hwid_ids))
    for token in tokens:
        token.save(db)
    print(f"Сгенерировано {len(tokens)} токенов")

    # Генерация и вставка данных для модели Version
    versions = list(generate_version_data(50, mod_ids))
    for version in versions:
        version.save(db)
    print(f"Сгенерировано {len(versions)} версий")

    print("Данные сгенерированы и успешно вставлены.")

def create_dump(db, output_file):
    """
    Создание дампа базы данных и сохранение его в файл.

    :param db: Объект Database для подключения к базе данных.
    :param output_file: Имя файла для сохранения дампа.
    """
    db.create_dump(output_file)
    print(f"Дамп базы данных '{db.dbname}' создан в файле '{output_file}'.")

if __name__ == "__main__":
    db = create_source_db_and_tables()
    generate_and_insert_data(db)
    create_dump(db, "source_db_dump.sql")
Файл investigations/__init__.py:


Файл investigations/research.py:

"""
Модуль для исследования производительности различных моделей и операций.

Импорты:
    - Подключаются необходимые модули и библиотеки для работы и визуализации данных.

Функции:
    - setup_sandbox: Создает песочницу для тестирования.
    - generate_data_for_table: Генерация данных для таблиц.
    - get_primary_key_name: Извлечение имени первичного ключа модели.
    - perform_queries: Выполнение различных запросов для замера времени.
    - measure_generate_time: Измерение времени генерации данных.
    - measure_insert_time: Измерение времени вставки данных.
    - measure_query_time: Измерение времени выполнения SQL-запроса.
    - measure_generation_times: Замер времени генерации данных.
    - measure_query_times: Замер времени выполнения запросов.
    - plot_results: Построение и сохранение графика с несколькими линиями.
    - plot_individual_query_times: Построение графиков времени выполнения запросов.
"""

import re
import sys
import os

# Добавляем путь к родительской директории для корректного импорта модулей
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import timeit
import matplotlib.pyplot as plt
from lib.data_generator import (
    generate_application_data, generate_user_data, generate_modification_data, generate_purchase_data, 
    generate_check_data, generate_hwid_data, generate_operation_data, generate_subscription_data, 
    generate_token_data, generate_version_data
)
from lib.db import Database
from lib.orm import Application, Users, Modification, Purchase, Checks, HWID, Operation, Subscription, Token, Version, Model
from lib.plot_utils import save_plot

# Настройка параметров исследования
DATABASE_NAME = 'research_db'
TABLES = [Application, Users, Modification, Purchase, Checks, HWID, Operation, Subscription, Token, Version]
ROW_COUNTS = list(range(10, 501, 35))
REPEAT = 3  # Количество повторов для каждого замера

def setup_sandbox(db_name):
    """
    Создает песочницу для тестирования.

    :param db_name: Имя базы данных песочницы.
    :return: Объект Database с именем песочницы.
    """
    with Database("postgres", user="postgres", password="secret6g2h2") as db:
        db.drop_db(db_name)
        db.create_db(db_name)
        db.clone_schema("source_db", db_name)
    return Database(db_name, user="postgres", password="secret6g2h2")

# Функции для генерации данных
def generate_data_for_table(table, count):
    """
    Генерация данных для заданной таблицы.

    :param table: Класс модели таблицы.
    :param count: Количество записей для генерации.
    :return: Список объектов модели.
    """
    generator_map = {
        Application: generate_application_data,
        Users: lambda n: generate_user_data(n, [1]),
        Modification: lambda n: generate_modification_data(n, [1]),
        Purchase: lambda n: generate_purchase_data(n, [1], [1]),
        Checks: lambda n: generate_check_data(n, [1]),
        HWID: lambda n: generate_hwid_data(n, [1]),
        Operation: lambda n: generate_operation_data(n, [1]),
        Subscription: lambda n: generate_subscription_data(n, [1], [1]),
        Token: lambda n: generate_token_data(n, [1], [1]),
        Version: lambda n: generate_version_data(n, [1])
    }
    return list(generator_map[table](count))

# Функция для извлечения имени первичного ключа
def get_primary_key_name(model_class):
    """
    Извлечение имени первичного ключа для модели.

    :param model_class: Класс модели.
    :return: Имя первичного ключа.
    """
    docstring = model_class.__doc__
    if docstring:
        field_definitions = re.findall(
            r'(\w+): FieldType\.(\w+)(, primary_key=True)?',
            docstring
        )
        for field_name, field_type, primary_key in field_definitions:
            if primary_key:
                return field_name
    raise ValueError(f"No primary key found for model {model_class.__name__}")

# Функции для выполнения запросов
def perform_queries(db, table):
    """
    Выполнение различных SQL-запросов для оценки производительности.

    :param db: Объект Database для подключения к базе данных.
    :param table: Класс модели таблицы.
    :return: Список временных характеристик выполнения запросов.
    """
    primary_key = get_primary_key_name(table)
    
    data = generate_data_for_table(table, 1)[0]  # Генерировать одну запись для вставки
    
    results = []
    
    # Время на вставку (INSERT)
    start_time = timeit.default_timer()
    data.save(db)
    duration = timeit.default_timer() - start_time
    results.append(duration)
    
    # Время на выборку всех записей (SELECT all)
    start_time = timeit.default_timer()
    records = table.get_all(db)
    duration = timeit.default_timer() - start_time
    results.append(duration)
    
    # Время на подсчёт записей (SELECT COUNT(*))
    start_time = timeit.default_timer()
    count = len(records)
    duration = timeit.default_timer() - start_time
    results.append(duration)
    
    # Время на выборку по условию, которое не подходит ни для одной записи
    start_time = timeit.default_timer()
    no_match = table.filter(db, **{primary_key: -1})
    duration = timeit.default_timer() - start_time
    results.append(duration)
    
    # Время на выборку по определённому первичному ключу
    if records:
        match_id = getattr(records[0], primary_key)
        start_time = timeit.default_timer()
        match = table.filter(db, **{primary_key: match_id})
        duration = timeit.default_timer() - start_time
        results.append(duration)
    
        # Время на обновление (UPDATE)
        if match and len(records[0].__dict__.keys()) > 1:
            updated_field = {list(records[0].__dict__.keys())[1]: "temp_value"}  # обновление второго поле в объекте
            start_time = timeit.default_timer()
            match[0].update(db, **updated_field)
            duration = timeit.default_timer() - start_time
            results.append(duration)
    
            
        if match:
            start_time = timeit.default_timer()
            match[0].delete(db)
            duration = timeit.default_timer() - start_time
            results.append(duration)
    
    return results

def measure_generate_time(model_class, n):
    """
    Измеряет время генерации данных для модели.

    :param model_class: Класс модели.
    :param n: Количество генерируемых записей.
    :return: Время генерации данных.
    """
    data_gen_map = {
        Application: lambda n: generate_application_data(n),
        Users: lambda n: generate_user_data(n, [1]),
        Modification: lambda n: generate_modification_data(n, [1]),
        Purchase: lambda n: generate_purchase_data(n, [1], [1]),
        Checks: lambda n: generate_check_data(n, [1]),
        HWID: lambda n: generate_hwid_data(n, [1]),
        Operation: lambda n: generate_operation_data(n, [1]),
        Subscription: lambda n: generate_subscription_data(n, [1], [1]),
        Token: lambda n: generate_token_data(n, [1], [1]),
        Version: lambda n: generate_version_data(n, [1])
    }

    def generate_data():
        list(data_gen_map[model_class](n))

    time = timeit.timeit(generate_data, number=1)
    return time

def measure_insert_time(db, model_class, n):
    """
    Измеряет время вставки данных для модели.

    :param db: Объект Database для подключения к базе данных.
    :param model_class: Класс модели.
    :param n: Количество вставляемых записей.
    :return: Время вставки данных.
    """
    data_gen_map = {
        Application: lambda n: generate_application_data(n),
        Users: lambda n: generate_user_data(n, [1]),
        Modification: lambda n: generate_modification_data(n, [1]),
        Purchase: lambda n: generate_purchase_data(n, [1], [1]),
        Checks: lambda n: generate_check_data(n, [1]),
        HWID: lambda n: generate_hwid_data(n, [1]),
        Operation: lambda n: generate_operation_data(n, [1]),
        Subscription: lambda n: generate_subscription_data(n, [1], [1]),
        Token: lambda n: generate_token_data(n, [1], [1]),
        Version: lambda n: generate_version_data(n, [1])
    }

    def insert_operation():
        for item in data_gen_map[model_class](n):
            item.save(db)

    time = timeit.timeit(insert_operation, number=1)
    return time

def measure_query_time(db, query):
    """
    Измеряет время выполнения SQL-запроса.

    :param db: Объект Database для подключения к базе данных.
    :param query: SQL-запрос для выполнения.
    :return: Время выполнения запроса.
    """
    def execute_query():
        with db.get_cursor() as cur:
            cur.execute(query)

    time = timeit.timeit(execute_query, number=1)
    return time

def measure_generation_times():
    """
    Замеряет время генерации данных для всех таблиц и различных размеров данных.

    :return: Словарь с результатами замеров времени генерации данных.
    """
    results = {}
    for table in TABLES:
        times_per_size = []
        for count in ROW_COUNTS:
            duration_sum = 0
            for _ in range(REPEAT):
                duration = measure_generate_time(table, count)
                duration_sum += duration
            avg_duration = duration_sum / REPEAT
            times_per_size.append(avg_duration)
        results[table.__name__] = times_per_size
    return results

def measure_query_times():
    """
    Замеряет время выполнения различных запросов для всех таблиц и различных размеров данных.

    :return: Словарь с результатами замеров времени выполнения запросов.
    """
    db = setup_sandbox(DATABASE_NAME)
    results = {}
    for table in TABLES:
        times_per_size = {}
        for count in ROW_COUNTS:
            # Замените данные в таблице заданного количества строк
            data = generate_data_for_table(table, count)
            with db.get_cursor() as cur:
                table_name = table.__name__.lower()
                cur.execute(f'DELETE FROM {table_name}')
                for record in data:
                    record.save(db)

            query_times = perform_queries(db, table)
            for i, query_time in enumerate(query_times):
                if i not in times_per_size:
                    times_per_size[i] = []
                times_per_size[i].append(query_time)
        results[table.__name__] = times_per_size
    return results

def plot_results(results, plot_title, x_label, y_label, filename):
    """
    Построение и сохранение графика с несколькими линиями.

    :param results: Словарь результатов, где ключ - название таблицы, значение - список времен.
    :param plot_title: Название графика.
    :param x_label: Подпись оси X.
    :param y_label: Подпись оси Y.
    :param filename: Имя файла для сохранения графика (без расширения).
    """
    labels = list(results.keys())
    x_values = ROW_COUNTS
    y_values = [results[label] for label in labels]
    
    save_plot(x_values, y_values, labels, plot_title, x_label, y_label, filename)

def plot_individual_query_times(results):
    """
    Построение графиков времени выполнения запросов для каждой таблицы.
    
    :param results: Словарь результатов выполнения запросов.
    """
    for table, times_per_size in results.items():
        for query_index, times in times_per_size.items():
            save_plot(ROW_COUNTS, [times], [f"Запрос {query_index}"], f"Время выполнения Запроса {query_index} для {table}", 'Количество строк', 'Время выполнения (с)', f"{table}_query_{query_index}_times")

# Основной исполнимый код
if __name__ == "__main__":
    # Замер времени генерации данных
    generation_times = measure_generation_times()
    plot_results(generation_times, "Время генерации", "Количество строк", "Время (s)", "generation_times")

    # Замер времени выполнения запросов
    query_times = measure_query_times()
    plot_individual_query_times(query_times)
Файл combine_files.sh:

#!/bin/bash

# Проверяем, передана ли папка как аргумент
if [ -z "$1" ]; then
  echo "Использование: $0 <папка>"
  exit 1
fi

# Проверяем, существует ли папка
if [ ! -d "$1" ]; then
  echo "Ошибка: Папка '$1' не найдена."
  exit 1
fi

# Создаем выходной файл (можно изменить название)
output_file="combined_files.txt"

# Проходим по всем файлам в папке (рекурсивно)
find "$1" -type f -print0 | while IFS= read -r -d $'\0' file; do

  # Получаем относительный путь до файла
  relative_path="${file#$1/}"

  # Добавляем информацию о файле и его содержимое в выходной файл
  echo "Файл ${relative_path}:" >> "$output_file"
  echo "" >> "$output_file"
  cat "$file" >> "$output_file"
  echo "" >> "$output_file"

done

echo "Готово! Все файлы скомпилированы в '$output_file'."
Файл lib/orm.py:

"""
Модуль для определения моделей ORM (Object-Relational Mapping).

Импорты:
    - Импортируются необходимые модули и библиотеки.

Классы:
    - FieldType: Перечисление типов данных для полей.
    - OperationType: Перечисление возможных типов операций (логин, логаут и т.д.)
    - Field: Класс для определения полей модели.
    - ModelMeta: Метакласс для динамического создания моделей.
    - Model: Базовый класс модели с методами для работы с БД (CRUD операции).

Примеры моделей:
    - Application: Модель приложения.
    - Users: Модель пользователей.
    - Modification: Модель модификаций.
    - Purchase, Checks, HWID, Operation, Subscription, Token, Version: Другие модели для различных данных.
"""

import re
from enum import Enum

class FieldType(Enum):
    """
    Перечисление типов данных для полей модели.
    """
    INT = "INT"
    SERIAL = "SERIAL"
    VARCHAR = "VARCHAR"
    DATE = "DATE"
    DATETIME = "TIMESTAMP"
    DECIMAL = "DECIMAL(10,2)"

class OperationType(Enum):
    """
    Перечисление типов операций.
    """
    LOGIN = "LOGIN"
    LOGOUT = "LOGOUT"
    PURCHASE = "PURCHASE"
    UPDATE_PROFILE = "UPDATE_PROFILE"

class Field:
    """
    Класс для определения поля модели.

    Атрибуты:
        - type: Тип данных поля.
        - primary_key: Является ли поле первичным ключом.
        - foreign_key: Внешний ключ, если есть.
        - max_length: Максимальная длина для строковых полей.
        - min_value: Минимальное значение для числовых полей.
        - max_value: Максимальное значение для числовых полей.
        - many_to_many: Является ли поле отношением many-to-many.
    """
    def __init__(self, type_, primary_key=False, foreign_key=None, max_length=None, min_value=None, max_value=None, many_to_many=False):
        if not isinstance(type_, FieldType):
            raise ValueError("Field type must be an instance of FieldType Enum")
        self.type = type_.value
        self.primary_key = primary_key
        self.foreign_key = foreign_key
        self.max_length = max_length
        self.min_value = min_value
        self.max_value = max_value
        self.many_to_many = many_to_many

class ModelMeta(type):
    """
    Метакласс для динамической генерации моделей.
    """
    def __new__(cls, name, bases, dct):
        docstring = dct.get('__doc__')
        if docstring:
            field_definitions = re.findall(
                r'(\w+): FieldType\.(\w+)(, primary_key=True)?(, foreign_key=\'(.+?)\')?(, max_length=(\d+))?(, min_value=(\d+))?(, max_value=(\d+))?(, many_to_many=True)?',
                docstring
            )
            for field_name, field_type, primary_key, _, foreign_key, _, max_length, _, min_value, _, max_value, many_to_many in field_definitions:
                primary_key = bool(primary_key)
                field_type_enum = FieldType[field_type]
                max_length = int(max_length) if max_length else None
                min_value = int(min_value) if min_value else None
                max_value = int(max_value) if max_value else None
                many_to_many = bool(many_to_many)
                dct[field_name] = Field(field_type_enum, primary_key, foreign_key, max_length, min_value, max_value, many_to_many)
        return super().__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        if not hasattr(cls, '_registry'):
            cls._registry = {}
        else:
            cls._registry[name] = cls
        super(ModelMeta, cls).__init__(name, bases, dct)

class Model(metaclass=ModelMeta):
    """
    Базовый класс для моделей. Определяет методы сохранения, удаления, обновления 
    и получения данных из базы данных.
    """
    primary_keys = {}  # глобальный словарь для хранения первичных ключей каждой таблицы
    many_to_many_tables = []  # глобальный список для хранения таблиц many-to-many

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
        for key, field in self.__class__.__dict__.items():
            if isinstance(field, Field) and key not in kwargs:
                setattr(self, key, None)

    @classmethod
    def create_table(cls, db):
        """
        Создание таблицы для модели.

        :param db: Объект Database для подключения к базе данных.
        """
        fields = []

        for attr, value in cls.__dict__.items():
            if isinstance(value, Field):
                field_def = f'{attr} {value.type}'
                if value.max_length:
                    field_def = f'{attr} VARCHAR({value.max_length})'
                if value.primary_key:
                    field_def += ' PRIMARY KEY'
                    Model.primary_keys[cls.__name__.lower()] = attr  # сохраняем первичный ключ
                if value.foreign_key:
                    field_def += f' REFERENCES {value.foreign_key}'
                fields.append(field_def)
                if value.many_to_many:
                    Model.many_to_many_tables.append((cls.__name__.lower(), attr, value.foreign_key.split('(')[0], value.foreign_key.split('(')[1][:-1]))

        query = f'CREATE TABLE IF NOT EXISTS {cls.__name__.lower()} ({", ".join(fields)});'
        with db.get_cursor() as cur:
            cur.execute(query)

    @classmethod
    def create_many_to_many_tables(cls, db):
        """
        Создание таблиц для отношений many-to-many.

        :param db: Объект Database для подключения к базе данных.
        """
        for table1, field1, table2, field2 in Model.many_to_many_tables:
            cls.create_many_to_many_table(db, table1, table2, Model.primary_keys)

    @staticmethod
    def create_many_to_many_table(db, table1, table2, primary_keys):
        """
        Статический метод для создания таблицы many-to-many.

        :param db: Объект Database для подключения к базе данных.
        :param table1: Первая таблица.
        :param table2: Вторая таблица.
        :param primary_keys: Словарь первичных ключей.
        """
        table_name = f'{table1}_{table2}'
        table1_pk = primary_keys[table1]
        table2_pk = primary_keys[table2]
        query = f'''
        CREATE TABLE IF NOT EXISTS {table_name} (
            {table1_pk} INT REFERENCES {table1}({table1_pk}),
            {table2_pk} INT REFERENCES {table2}({table2_pk}),
            PRIMARY KEY ({table1_pk}, {table2_pk})
        );
        '''
        with db.get_cursor() as cur:
            cur.execute(query)

    def extract_field_values(self):
        """
        Извлечение значений полей для вставки или обновления.

        :return: Список имен полей и список значений полей.
        """
        columns = []
        values = []
        for attr, field in self.__class__.__dict__.items():
            if isinstance(field, Field):
                value = getattr(self, attr)
                if isinstance(value, Enum):
                    value = value.value
                if value is None and field.primary_key:
                    continue
                columns.append(attr)
                values.append(value)
        return columns, values

    def save(self, db):
        """
        Сохранение текущего объекта модели в базу данных.

        :param db: Объект Database для подключения к базе данных.
        """
        columns, values = self.extract_field_values()

        if not columns:
            raise ValueError("No fields found to insert.")

        column_names = ", ".join(columns)
        placeholders = ", ".join(["%s"] * len(columns))

        query = f'INSERT INTO {self.__class__.__name__.lower()} ({column_names}) VALUES ({placeholders}) RETURNING *;'
        with db.get_cursor() as cur:
            cur.execute(query, values)
            returned_values = cur.fetchone()
            for key, value in zip(columns, returned_values):
                setattr(self, key, value)

    @classmethod
    def get_all(cls, db):
        """
        Получение всех записей из таблицы.

        :param db: Объект Database для подключения к базе данных.
        :return: Список объектов модели.
        """
        query = f'SELECT * FROM {cls.__name__.lower()};'
        with db.get_cursor() as cur:
            cur.execute(query)
            records = cur.fetchall()
            results = []
            for record in records:
                obj = cls(**dict(zip([col[0] for col in cur.description], record)))
                results.append(obj)
            return results

    @classmethod
    def filter(cls, db, **kwargs):
        """
        Фильтрация записей по заданным условиям.

        :param db: Объект Database для подключения к базе данных.
        :param kwargs: Словарь условий фильтрации.
        :return: Список объектов модели, соответствующих условиям.
        """
        conditions = [f"{key} = %s" for key in kwargs.keys()]
        query = f"SELECT * FROM {cls.__name__.lower()} WHERE {' AND '.join(conditions)}"

        with db.get_cursor() as cur:
            cur.execute(query, tuple(kwargs.values()))
            records = cur.fetchall()
            results = []
            for record in records:
                obj = cls(**dict(zip([col[0] for col in cur.description], record)))
                results.append(obj)
            return results

    def delete(self, db):
        """
        Удаление текущего объекта модели из базы данных.

        :param db: Объект Database для подключения к базе данных.
        """
        pk_name = Model.primary_keys[self.__class__.__name__.lower()]
        query = f"DELETE FROM {self.__class__.__name__.lower()} WHERE {pk_name} = %s"
        with db.get_cursor() as cur:
            cur.execute(query, (getattr(self, pk_name),))

    def update(self, db, **kwargs):
        """
        Обновление полей текущего объекта модели в базе данных.

        :param db: Объект Database для подключения к базе данных.
        :param kwargs: Словарь полей и значений для обновления.
        """
        pk_name = Model.primary_keys[self.__class__.__name__.lower()]
        set_clause = ", ".join([f"{key} = %s" for key in kwargs.keys()])
        query = f"UPDATE {self.__class__.__name__.lower()} SET {set_clause} WHERE {pk_name} = %s"
        values = tuple(kwargs.values()) + (getattr(self, pk_name),)
        with db.get_cursor() as cur:
            cur.execute(query, values)
            for key, value in kwargs.items():
                setattr(self, key, value)

            # Для получения обновленных значений после выполнения запроса
            query = f"SELECT * FROM {self.__class__.__name__.lower()} WHERE {pk_name} = %s"
            cur.execute(query, (getattr(self, pk_name),))
            updated_record = cur.fetchone()
            if updated_record:
                for key, value in zip([col[0] for col in cur.description], updated_record):
                    setattr(self, key, value)

# Пример моделей
class Application(Model):
    """
    app_id: FieldType.SERIAL, primary_key=True
    app_name: FieldType.VARCHAR, max_length=255
    """

class Users(Model):
    """
    user_id: FieldType.SERIAL, primary_key=True
    full_name: FieldType.VARCHAR, max_length=100
    email: FieldType.VARCHAR, max_length=255
    password: FieldType.VARCHAR, max_length=100
    registration_date: FieldType.DATE
    app_availability: FieldType.INT, foreign_key='application(app_id)', min_value=1, max_value=100
    subscriptions: FieldType.INT, foreign_key='modification(mod_id)', many_to_many=True
    """

class Modification(Model):
    """
    mod_id: FieldType.SERIAL, primary_key=True
    mod_name: FieldType.VARCHAR, max_length=100
    mod_desc: FieldType.VARCHAR, max_length=255
    app_id: FieldType.INT, foreign_key='application(app_id)', min_value=1, max_value=100
    """

class Purchase(Model):
    """
    purchase_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    purchase_date: FieldType.DATE
    """

class Checks(Model):
    """
    check_id: FieldType.SERIAL, primary_key=True
    purchase_id: FieldType.INT, foreign_key='purchase(purchase_id)', min_value=1, max_value=100
    amount: FieldType.DECIMAL
    payment_method: FieldType.VARCHAR, max_length=50
    """

class HWID(Model):
    """
    hwid_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    processor: FieldType.VARCHAR, max_length=50
    videocard: FieldType.VARCHAR, max_length=50
    os_version: FieldType.VARCHAR, max_length=50
    os_type: FieldType.VARCHAR, max_length=50
    disks: FieldType.VARCHAR, max_length=50
    network_card: FieldType.VARCHAR, max_length=50
    """

class Operation(Model):
    """
    operation_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    operation_type: FieldType.VARCHAR, max_length=100
    operation_date: FieldType.DATETIME
    """

class Subscription(Model):
    """
    subscription_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    subscription_time: FieldType.DATETIME
    """

class Token(Model):
    """
    token_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    hwid_id: FieldType.INT, foreign_key='hwid(hwid_id)', min_value=1, max_value=100
    last_login: FieldType.DATETIME
    """

class Version(Model):
    """
    version_id: FieldType.SERIAL, primary_key=True
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    version_number: FieldType.INT, min_value=1, max_value=10
    version_name: FieldType.VARCHAR, max_length=50
    version_description: FieldType.VARCHAR, max_length=255
    version_link: FieldType.VARCHAR, max_length=255
    """
Файл lib/data_generator.py:

"""
Модуль для генерации данных для моделей.

Импорты:
    - Импортируются необходимые модули и библиотеки.

Функции:
    - Генерация случайных строк, email, дат, целых чисел.
    - Генерация данных для каждой модели (Application, Users, Modification и т.д.)
"""

import random
import string
from datetime import datetime, timedelta

def random_string(length):
    """
    Генерация случайной строки заданной длины.

    :param length: Длина строки.
    :return: Случайная строка.
    """
    letters = string.ascii_letters + string.digits
    return ''.join(random.choice(letters) for _ in range(length))

def random_email():
    """
    Генерация случайного email.

    :return: Случайный email.
    """
    domains = ["example.com", "test.com", "mydomain.com", "economic-crisis.com", "baka.com", "gmail.com", "ya.ru", "mail.ru", "yandex.ru", "yahoo.com", "outlook.com", "hotmail.com", "protonmail.com", "tutanota.com", "aol.com", "icloud.com", "inbox.lv", "zoho.com", "gmx.com", "yopmail.com", "mailinator.com", "guerrillamail.com", "10minutemail.com", "temp-mail.org", "maildrop.cc", "dispostable.com", "throwawaymail.com", "tempmailaddress.com", "mailnesia.com", "trashmail.com", "mailsac.com", "getnada.com", "anonaddy.com", "burnermail.io", "simplelogin.io", "scryptmail.com", "mailbox.org", "posteo.de", "tutanota.com", "mailbox.org", "disroot.org", "riseup.net", "autistici.org"]
    email = f"{random_string(5).lower()}@{random.choice(domains)}"
    return email

def random_date(start, end):
    """
    Генерация случайной даты в заданном диапазоне.

    :param start: Начальная дата диапазона.
    :param end: Конечная дата диапазона.
    :return: Случайная дата.
    """
    delta = end - start
    return start + timedelta(days=random.randint(0, delta.days))

def random_int(min_val, max_val):
    """
    Генерация случайного целого числа в заданном диапазоне.

    :param min_val: Минимальное значение (включительно).
    :param max_val: Максимальное значение (включительно).
    :return: Случайное целое число.
    """
    return random.randint(min_val, max_val)

def generate_full_name():
    """
    Генерация случайного ФИО.

    :return: Случайное ФИО.
    """
    first_names = ["Иван", "Темур", "Николай", "Петр", "Алексей", "Дмитрий", "Сергей"]
    last_names = ["Иванов", "Петров", "Сидоров", "Кузнецов", "Смирнов", "Cпиридонов", "Кукушкин", "Исмагилов"]
    middle_names = ["Алексеевич", "Сергеевич", "Дмитриевич", "Владимирович", "Андреевич"]
    
    return f"{random.choice(last_names)} {random.choice(first_names)} {random.choice(middle_names)}"

def generate_app_name():
    """
    Генерация случайного названия приложения.

    :return: Случайное название приложения.
    """
    app_prefixes = ["Super", "Mega", "Ultra", "Hyper", "Tech"]
    app_suffixes = ["App", "Tool", "Software", "Manager", "System"]
    
    return f"{random.choice(app_prefixes)}{random.choice(app_suffixes)}"

def generate_modification_name():
    """
    Генерация случайного названия модификации.

    :return: Случайное название модификации.
    """
    mod_prefixes = ["Pro", "Lite", "Advanced", "Basic", "Premium", "Free", "Trial", "Ultimate", "Standard", "Professional", "Community"]
    mod_suffixes = ["Edition", "Version", "Setup", "Pack", "Kit", "Release", "Update", "Patch", "Build"]
    
    return f"{random.choice(mod_prefixes)} {random.choice(mod_suffixes)}"

def generate_modification_description():
    """
    Генерация случайного описания модификации.

    :return: Случайное описание модификации.
    """
    descriptions = [
        "Эта модификация включает в себя улучшения производительности",
        "Версия с новыми функциями и исправлениями",
        "Обновление, которое повышает стабильность работы",
        "Новое издание со всеми доступными дополнениями",
        "Более легкая версия с оптимизированными ресурсами",
        "Бесплатная версия для тестирования",
        "Профессиональная версия для опытных пользователей",
        "Сообщество разработчиков представляет новую версию",
        "Версия с расширенными возможностями",
        "Версия для всех пользователей",
        "Сборка с исправлениями уязвимостей и обновлениями",
        "Новое обновление с новыми функциями и улучшениями",
    ]
    
    return random.choice(descriptions)

def generate_payment_method():
    """
    Генерация случайного метода платежа.

    :return: Случайный метод платежа.
    """
    methods = ["Credit Card", "MasterCard", "Visa", "Mir", "Mir Pay", "Tinkoff Pay", "PayPal", "Bank Transfer", "Bitcoin", "Gift Card", "Apple Pay", "Google Pay", "Samsung Pay", "Cash", "Cryptocurrency", "WebMoney", "Yandex Money", "Qiwi Wallet", "Alipay", "WeChat Pay", "Venmo", "Zelle", "Cash App", "Stripe", "Square", "TransferWise", "Revolut", "Payoneer", "Skrill", "Neteller", "Paysera", "Payza", "Perfect Money", "Payeer", "AdvCash", "Paxum", "PaySera", "Epay", "Ecopayz", "WebMoney", "Yandex Money", "Qiwi Wallet", "Alipay", "WeChat Pay", "Venmo", "Zelle", "Cash App", "Stripe", "Square", "TransferWise", "Revolut", "Payoneer", "Skrill", "Neteller", "Paysera", "Payza", "Perfect Money", "Payeer", "AdvCash"]
    
    return random.choice(methods)

def generate_pc_parameters():
    """
    Генерация случайных параметров ПК.

    :return: Словарь с параметрами ПК.
    """
    processors = ["Intel Core i7", "AMD Ryzen 5", "Intel Core i5", "AMD Ryzen 7", "Intel Core i9", "AMD Ryzen 9", "Intel Xeon", "AMD Threadripper", "Intel Pentium", "AMD Athlon", "Intel Celeron", "AMD A-Series"]
    videocards = ["NVIDIA GTX 1650", "AMD Radeon RX 5700", "NVIDIA RTX 2060", "AMD RX 580", "NVIDIA RTX 3080", "AMD RX 6800", "NVIDIA GTX 1050", "AMD RX 560", "NVIDIA RTX 3090", "AMD RX 6900", "NVIDIA GTX 1660", "AMD RX 570", "NVIDIA RTX 3070", "AMD RX 6700", "NVIDIA GTX 1070", "AMD RX 550", "NVIDIA RTX 3060", "AMD RX 6600", "NVIDIA GTX 1080", "AMD RX 5300"]
    os_versions = ["Windows 10", "Windows 11", "Ubuntu 20.04", "macOS Catalina", "Fedora 34", "Debian 11", "CentOS 8", "Arch Linux", "openSUSE Leap", "Linux Mint", "Kali Linux", "Manjaro", "Zorin OS", "Pop!_OS", "elementary OS", "Solus", "Deepin", "MX Linux", "EndeavourOS", "Garuda Linux", "ArcoLinux", "Parrot OS", "Slackware", "Gentoo", "Void Linux", "Alpine Linux", "LFS", "ReactOS", "FreeDOS", "Haiku", "Plan 9", "TempleOS", "RISC OS", "AmigaOS", "BeOS", "QNX", "MS-DOS", "CP/M", "OS/2", "Unix"]
    os_types = ["32-bit", "64-bit"]
    disks = ["HDD 1TB", "SSD 256GB", "Hybrid 1TB", "NVMe SSD 512GB", "SATA SSD 1TB", "M.2 SSD 2TB", "PCIe SSD 1TB", "SAS HDD 2TB", "SCSI HDD 1TB", "eMMC 128GB", "USB Flash 64GB", "SD Card 32GB", "CF Card 16GB", "MicroSD 8GB", "CompactFlash 4GB", "Floppy Disk 1.44MB", "Zip Disk 100MB", "Jaz Disk 1GB", "CD-ROM 700MB", "DVD-RW 4.7GB", "BD-R 25GB", "HD-DVD 15GB", "Blu-ray 50GB", "UHD Blu-ray 100GB", "VHS Tape"]
    network_cards = ["Realtek PCIe", "Intel Ethernet", "Qualcomm Atheros", "Broadcom Ethernet", "Killer Wireless", "Marvell AVASTAR", "Ralink Wireless", "Aquantia AQtion", "ASUS PCE-AC88", "TP-Link Archer", "D-Link DWA", "Netgear Nighthawk", "Linksys WRT", "Cisco Catalyst", "MikroTik Router", "Ubiquiti UniFi", "Zyxel Nebula", "Aruba Instant", "Fortinet FortiGate", "SonicWall TZ", "Palo Alto Networks", "Sophos XG", "Check Point", "Juniper SRX", "F5 BIG-IP", "Citrix NetScaler", "Barracuda CloudGen", "WatchGuard Firebox", "ZyXEL ZyWALL", "Huawei USG", "HPE Aruba", "Ruckus Wireless", "Meraki MR", "Open Mesh", "Mist Systems", "Aerohive HiveAP", "Aruba Instant", "Fortinet FortiAP", "SonicWall SonicPoint", "Palo Alto Networks PA", "Sophos AP", "Check Point 700", "Juniper WLA", "F5 BIG-IP", "Citrix Access Point", "Barracuda CloudGen", "WatchGuard AP", "ZyXEL NWA", "Huawei AP", "HPE Aruba AP", "Ruckus ZoneFlex", "Meraki MR", "Open Mesh AP", "Mist AP", "Aerohive AP"]
    
    return {
        'processor': random.choice(processors),
        'videocard': random.choice(videocards),
        'os_version': random.choice(os_versions),
        'os_type': random.choice(os_types),
        'disks': random.choice(disks),
        'network_card': random.choice(network_cards)
    }

def generate_application_data(n):
    """
    Генерация списка объектов Application.

    :param n: Количество объектов для генерации.
    :yield: Объект Application.
    """
    from lib.orm import Application
    for _ in range(n):
        yield Application(app_name=generate_app_name())

def generate_user_data(n, app_ids):
    """
    Генерация списка объектов Users.

    :param n: Количество объектов для генерации.
    :param app_ids: Список идентификаторов приложений.
    :yield: Объект Users.
    """
    from lib.orm import Users
    now = datetime.now()
    for _ in range(n):
        yield Users(
            full_name=generate_full_name(),
            email=random_email(),
            password=random_string(12),
            registration_date=random_date(now - timedelta(days=730), now).date(),
            app_availability=random.choice(app_ids)
        )

def generate_modification_data(n, app_ids):
    """
    Генерация списка объектов Modification.

    :param n: Количество объектов для генерации.
    :param app_ids: Список идентификаторов приложений.
    :yield: Объект Modification.
    """
    from lib.orm import Modification
    for _ in range(n):
        yield Modification(
            mod_name=generate_modification_name(),
            mod_desc=generate_modification_description(),
            app_id=random.choice(app_ids)
        )

def generate_purchase_data(n, user_ids, mod_ids):
    """
    Генерация списка объектов Purchase.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Purchase.
    """
    from lib.orm import Purchase
    now = datetime.now()
    for _ in range(n):
        yield Purchase(
            user_id=random.choice(user_ids),
            mod_id=random.choice(mod_ids),
            purchase_date=random_date(now - timedelta(days=365), now).date()
        )

def generate_check_data(n, purchase_ids):
    """
    Генерация списка объектов Checks.

    :param n: Количество объектов для генерации.
    :param purchase_ids: Список идентификаторов покупок.
    :yield: Объект Checks.
    """
    from lib.orm import Checks
    for _ in range(n):
        yield Checks(
            purchase_id=random.choice(purchase_ids),
            amount=round(random.uniform(1, 100), 2),
            payment_method=generate_payment_method()
        )

def generate_hwid_data(n, user_ids):
    """
    Генерация списка объектов HWID.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :yield: Объект HWID.
    """
    from lib.orm import HWID
    for _ in range(n):
        pc_params = generate_pc_parameters()
        yield HWID(
            user_id=random.choice(user_ids),
            processor=pc_params['processor'],
            videocard=pc_params['videocard'],
            os_version=pc_params['os_version'],
            os_type=pc_params['os_type'],
            disks=pc_params['disks'],
            network_card=pc_params['network_card']
        )

def generate_operation_data(n, user_ids):
    """
    Генерация списка объектов Operation.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :yield: Объект Operation.
    """
    from lib.orm import Operation
    now = datetime.now()
    for _ in range(n):
        yield Operation(
            user_id=random.choice(user_ids),
            operation_type=random_string(15),  # Например, тип операции можно создавать как случайную строку длиной 15
            operation_date=random_date(now - timedelta(days=365), now)
        )

def generate_subscription_data(n, user_ids, mod_ids):
    """
    Генерация списка объектов Subscription.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Subscription.
    """
    from lib.orm import Subscription
    now = datetime.now()
    for _ in range(n):
        yield Subscription(
            user_id=random.choice(user_ids),
            mod_id=random.choice(mod_ids),
            subscription_time=random_date(now - timedelta(days=365), now)
        )

def generate_token_data(n, user_ids, hwid_ids):
    """
    Генерация списка объектов Token.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param hwid_ids: Список идентификаторов HWID.
    :yield: Объект Token.
    """
    from lib.orm import Token
    now = datetime.now()
    for _ in range(n):
        yield Token(
            user_id=random.choice(user_ids),
            hwid_id=random.choice(hwid_ids),
            last_login=random_date(now - timedelta(days=365), now)
        )

def generate_version_data(n, mod_ids):
    """
    Генерация списка объектов Version.

    :param n: Количество объектов для генерации.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Version.
    """ 
    from lib.orm import Version
    version_prefixes = ["1.0", "1.1", "2.0", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0", "11.0", "12.0", "13.0", "14.0", "15.0"]
    version_suffixes = ["Alpha", "Beta", "Release", "Stable", "Final"]
    descriptions = [
        "Первоначальный выпуск с базовой функциональностью.",
        "Это обновление включает исправления и улучшения производительности.",
        "Новое крупное обновление с дополнительными функциями.",
        "Исправлены ошибки предыдущих выпусков.",
        "Конечный стабильный выпуск.",
        "Это обновление содержит новые возможности и улучшения.",
        "Сборка с исправлениями уязвимостей и обновлениями.",
        "Новое обновление с новыми функциями и улучшениями.",
        "Это обновление включает исправления и улучшения производительности.",
        "Новое крупное обновление с дополнительными функциями.",
    ]

    for _ in range(n):
        version_number = f"{random.choice(version_prefixes)}.{random_int(0, 9)}"
        version_name = f"{version_number} {random.choice(version_suffixes)}"
        
        yield Version(
            mod_id=random.choice(mod_ids),
            version_number=random_int(1, 200),
            version_name=version_name,
            version_description=random.choice(descriptions),
            version_link=f"http://new-version-{random_string(10)}.com"
        )
Файл lib/__init__.py:


Файл lib/__pycache__/plot_utils.cpython-311.pyc:


    >qfY                         d Z ddlmZ ddZdS )u[  
Модуль для построения и сохранения графиков.

Импорты:
    - Импортируется модуль matplotlib.pyplot для построения графиков.

Функции:
    - save_plot: Построение и сохранение графика с несколькими линиями.
    Npng
      c	                 p   g d}	g d}
t          j        |           t          t          ||                    D ]f\  }\  }}|	|t	          |	          z           }t	          |           dk    r|
|t	          |
          z           nd}t          j        | ||||           gt          j        |           t          j        |           t          j        |           t          j	                     t          j
        d           |D ]}t          j        | d|            t          j                     dS )	u
  
    Построение и сохранение графика с несколькими линиями.

    :param x_values: Список значений по оси X.
    :param y_values: Список списков значений по оси Y для каждой линии.
    :param labels: Список меток для каждой линии.
    :param title: Название графика.
    :param xlabel: Подпись оси X.
    :param ylabel: Подпись оси Y.
    :param filename: Имя файла для сохранения графика (без расширения).
    :param formats: Форматы для сохранения (например, ['png', 'svg']).
    :param figsize: Размер фигуры графика.
    )-z--z-.:)	osD^v<>p*)figsizer   N)label	linestylemarkerT.)pltfigure	enumerateziplenplottitlexlabelylabellegendgridsavefigclose)x_valuesy_valueslabelsr   r    r!   filenameformatsr   
linestylesmarkersiyr   r   r   fmts                    5/home/server/python-orm-enikeev/orm/lib/plot_utils.py	save_plotr1      s<    (''J;;;GJw"3x#8#899 O O:Auq3z??23	.1(mmb.@.@S\\)**d1EYvNNNNNIeJvJvJLLLHTNNN ) )x''#''((((IKKKKK    )r   r   )__doc__matplotlib.pyplotpyplotr   r1    r2   r0   <module>r7      sA           ! ! ! ! ! !r2   
Файл lib/__pycache__/__init__.cpython-311.pyc:


    gc                           d S )N r       3/home/server/python-orm-enikeev/orm/lib/__init__.py<module>r      s     r   
Файл lib/__pycache__/data_generator.cpython-311.pyc:


    qf5D                         d Z ddlZddlZddlmZmZ d Zd Zd Zd Zd Z	d	 Z
d
 Zd Zd Zd Zd Zd Zd Zd Zd Zd Zd Zd Zd Zd ZdS )u  
Модуль для генерации данных для моделей.

Импорты:
    - Импортируются необходимые модули и библиотеки.

Функции:
    - Генерация случайных строк, email, дат, целых чисел.
    - Генерация данных для каждой модели (Application, Users, Modification и т.д.)
    N)datetime	timedeltac                     t           j        t           j        z   d                    fdt	          |           D                       S )u   
    Генерация случайной строки заданной длины.

    :param length: Длина строки.
    :return: Случайная строка.
     c              3   @   K   | ]}t          j                  V  d S )Nrandomchoice).0_letterss     9/home/server/python-orm-enikeev/orm/lib/data_generator.py	<genexpr>z random_string.<locals>.<genexpr>   s-      AAa6=))AAAAAA    )stringascii_lettersdigitsjoinrange)lengthr   s    @r   random_stringr      sA     "V]2G77AAAA5==AAAAAAr   c                  ~    g d} t          d                                           dt          j        |            }|S )u`   
    Генерация случайного email.

    :return: Случайный email.
    )+zexample.comztest.comzmydomain.comzeconomic-crisis.comzbaka.comz	gmail.comzya.ruzmail.ruz	yandex.ruz	yahoo.comzoutlook.comzhotmail.comzprotonmail.comtutanota.comzaol.comz
icloud.comzinbox.lvzzoho.comzgmx.comzyopmail.comzmailinator.comzguerrillamail.comz10minutemail.comztemp-mail.orgzmaildrop.cczdispostable.comzthrowawaymail.comztempmailaddress.comzmailnesia.comztrashmail.comzmailsac.comzgetnada.comzanonaddy.comzburnermail.iozsimplelogin.iozscryptmail.commailbox.orgz	posteo.der   r   zdisroot.orgz
riseup.netzautistici.org   @)r   lowerr	   r
   )domainsemails     r   random_emailr       sL     k
  k
  k
GQ%%''BB&-*@*@BBELr   c                 b    || z
  }| t          t          j        d|j                            z   S )u  
    Генерация случайной даты в заданном диапазоне.

    :param start: Начальная дата диапазона.
    :param end: Конечная дата диапазона.
    :return: Случайная дата.
    r   days)r   r	   randintr#   )startenddeltas      r   random_dater(   $   s1     %KE9&.EJ"?"?@@@@@r   c                 ,    t          j        | |          S )u[  
    Генерация случайного целого числа в заданном диапазоне.

    :param min_val: Минимальное значение (включительно).
    :param max_val: Максимальное значение (включительно).
    :return: Случайное целое число.
    )r	   r$   )min_valmax_vals     r   
random_intr,   /   s     >'7+++r   c                      g d} g d}g d}t          j        |           dt          j        |            dt          j        |           S )ub   
    Генерация случайного ФИО.

    :return: Случайное ФИО.
    )u   Иванu
   Темурu   Николайu   Петрu   Алексейu   Дмитрийu   Сергей)u   Ивановu   Петровu   Сидоровu   Кузнецовu   Смирновu   Cпиридоновu   Кукушкинu   Исмагилов)u   Алексеевичu   Сергеевичu   Дмитриевичu   Владимировичu   Андреевич r   )first_names
last_namesmiddle_namess      r   generate_full_namer2   9   ss     ~~K k  k  kJ L  L  LLmJ''dd&-*D*Dddv}UaGbGbdddr   c                  f    g d} g d}t          j        |            t          j        |           S )u   
    Генерация случайного названия приложения.

    :return: Случайное название приложения.
    )SuperMegaUltraHyperTech)AppToolSoftwareManagerSystemr   )app_prefixesapp_suffixess     r   generate_app_namer@   E   s?     ?>>LCCCLmL))H6=+F+FHHHr   c                  h    g d} g d}t          j        |            dt          j        |           S )u   
    Генерация случайного названия модификации.

    :return: Случайное название модификации.
    )ProLiteAdvancedBasicPremiumFreeTrialUltimateStandardProfessional	Community)	EditionVersionSetupPackKitReleaseUpdatePatchBuildr.   r   )mod_prefixesmod_suffixess     r   generate_modification_namerX   P   sI     I  I  ILhhhLmL))IIFM,,G,GIIIr   c                  2    g d} t          j        |           S )u   
    Генерация случайного описания модификации.

    :return: Случайное описание модификации.
    )ur   Эта модификация включает в себя улучшения производительностиuM   Версия с новыми функциями и исправлениямиu[   Обновление, которое повышает стабильность работыuW   Новое издание со всеми доступными дополнениямиu]   Более легкая версия с оптимизированными ресурсамиuA   Бесплатная версия для тестированияu^   Профессиональная версия для опытных пользователейu`   Сообщество разработчиков представляет новую версиюuC   Версия с расширенными возможностямиu7   Версия для всех пользователейu]   Сборка с исправлениями уязвимостей и обновлениямиu\   Новое обновление с новыми функциями и улучшениямиr   )descriptionss    r   !generate_modification_descriptionr[   [   s%      L =&&&r   c                  2    g d} t          j        |           S )u   
    Генерация случайного метода платежа.

    :return: Случайный метод платежа.
    );zCredit Card
MasterCardVisaMirzMir PayzTinkoff PayPayPalzBank TransferBitcoinz	Gift Cardz	Apple Payz
Google PayzSamsung PayCashCryptocurrencyWebMoneyYandex MoneyQiwi WalletAlipay
WeChat PayVenmoZelleCash AppStripeSquareTransferWiseRevolutPayoneerSkrillNetellerPayseraPayzaPerfect MoneyPayeerAdvCashPaxumPaySeraEpayEcopayzrd   re   rf   rg   rh   ri   rj   rk   rl   rm   rn   ro   rp   rq   rr   rs   rt   ru   rv   rw   r   )methodss    r   generate_payment_methodr}   r   s&     K  K  KG=!!!r   c                     g d} g d}g d}ddg}g d}g d}t          j        |           t          j        |          t          j        |          t          j        |          t          j        |          t          j        |          dS )	u   
    Генерация случайных параметров ПК.

    :return: Словарь с параметрами ПК.
    )zIntel Core i7zAMD Ryzen 5zIntel Core i5zAMD Ryzen 7zIntel Core i9zAMD Ryzen 9z
Intel XeonzAMD ThreadripperzIntel Pentiumz
AMD AthlonzIntel CeleronzAMD A-Series)zNVIDIA GTX 1650zAMD Radeon RX 5700zNVIDIA RTX 2060z
AMD RX 580zNVIDIA RTX 3080zAMD RX 6800zNVIDIA GTX 1050z
AMD RX 560zNVIDIA RTX 3090zAMD RX 6900zNVIDIA GTX 1660z
AMD RX 570zNVIDIA RTX 3070zAMD RX 6700zNVIDIA GTX 1070z
AMD RX 550zNVIDIA RTX 3060zAMD RX 6600zNVIDIA GTX 1080zAMD RX 5300)(z
Windows 10z
Windows 11zUbuntu 20.04zmacOS Catalinaz	Fedora 34z	Debian 11zCentOS 8z
Arch LinuxzopenSUSE Leapz
Linux Mintz
Kali LinuxManjarozZorin OSzPop!_OSzelementary OSSolusDeepinzMX LinuxEndeavourOSzGaruda Linux	ArcoLinuxz	Parrot OS	SlackwareGentooz
Void LinuxzAlpine LinuxLFSReactOSFreeDOSHaikuzPlan 9TempleOSzRISC OSAmigaOSBeOSQNXzMS-DOSzCP/MzOS/2Unixz32-bitz64-bit)zHDD 1TBz	SSD 256GBz
Hybrid 1TBzNVMe SSD 512GBzSATA SSD 1TBzM.2 SSD 2TBzPCIe SSD 1TBzSAS HDD 2TBzSCSI HDD 1TBz
eMMC 128GBzUSB Flash 64GBzSD Card 32GBzCF Card 16GBzMicroSD 8GBzCompactFlash 4GBzFloppy Disk 1.44MBzZip Disk 100MBzJaz Disk 1GBzCD-ROM 700MBzDVD-RW 4.7GBz	BD-R 25GBzHD-DVD 15GBzBlu-ray 50GBzUHD Blu-ray 100GBzVHS Tape)7zRealtek PCIezIntel EthernetzQualcomm AtheroszBroadcom EthernetzKiller WirelesszMarvell AVASTARzRalink WirelesszAquantia AQtionzASUS PCE-AC88zTP-Link Archerz
D-Link DWAzNetgear NighthawkzLinksys WRTzCisco CatalystzMikroTik RouterzUbiquiti UniFizZyxel NebulaAruba InstantzFortinet FortiGatezSonicWall TZzPalo Alto Networksz	Sophos XGzCheck PointzJuniper SRX	F5 BIG-IPzCitrix NetScalerBarracuda CloudGenzWatchGuard FireboxzZyXEL ZyWALLz
Huawei USGz	HPE ArubazRuckus Wireless	Meraki MRz	Open MeshzMist SystemszAerohive HiveAPr   zFortinet FortiAPzSonicWall SonicPointzPalo Alto Networks PAz	Sophos APzCheck Point 700zJuniper WLAr   zCitrix Access Pointr   zWatchGuard APz	ZyXEL NWAz	Huawei APzHPE Aruba APzRuckus ZoneFlexr   zOpen Mesh APzMist APzAerohive AP)	processor	videocard
os_versionos_typedisksnetwork_cardr   )
processors
videocardsos_versionsos_typesr   network_cardss         r   generate_pc_parametersr   |   s     T  T  TJ i  i  iJ u  u  uK(#H [  [  [E L  L  LM ]:..]:..mK00=**u%%m44  r   c              #   n   K   ddl m} t          |           D ]} |t                                V  dS )u   
    Генерация списка объектов Application.

    :param n: Количество объектов для генерации.
    :yield: Объект Application.
    r   )Application)app_nameN)lib.ormr   r   r@   )nr   r   s      r   generate_application_datar      s\       $#####1XX 8 8k#4#6#677777778 8r   c              #   T  K   ddl m} t          j                    }t	          |           D ]|} |t                      t                      t          d          t          |t          d          z
  |          
                                t          j        |                    V  }dS )u  
    Генерация списка объектов Users.

    :param n: Количество объектов для генерации.
    :param app_ids: Список идентификаторов приложений.
    :yield: Объект Users.
    r   )Users   i  r"   )	full_namer   passwordregistration_dateapp_availabilityN)r   r   r   nowr   r2   r    r   r(   r   dater	   r
   )r   app_idsr   r   r   s        r   generate_user_datar      s       
,..C1XX 
 
e(**.."2&&)#	s0C0C0C*CSIINNPP#]733
 
 
 	
 	
 	
 	

 
r   c              #      K   ddl m} t          |           D ]<} |t                      t	                      t          j        |                    V  =dS )u  
    Генерация списка объектов Modification.

    :param n: Количество объектов для генерации.
    :param app_ids: Список идентификаторов приложений.
    :yield: Объект Modification.
    r   )Modification)mod_namemod_descapp_idN)r   r   r   rX   r[   r	   r
   )r   r   r   r   s       r   generate_modification_datar      s       %$$$$$1XX 
 
l/11688=))
 
 
 	
 	
 	
 	

 
r   c              #   *  K   ddl m} t          j                    }t	          |           D ]g} |t          j        |          t          j        |          t          |t          d          z
  |          	                                          V  hdS )ul  
    Генерация списка объектов Purchase.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Purchase.
    r   )Purchasem  r"   )user_idmod_idpurchase_dateN)
r   r   r   r   r   r	   r
   r(   r   r   )r   user_idsmod_idsr   r   r   s         r   generate_purchase_datar      s       !     
,..C1XX 
 
hM(++=))%cI3,?,?,?&?EEJJLL
 
 
 	
 	
 	
 	

 
r   c           
   #      K   ddl m} t          |           D ]Q} |t          j        |          t          t          j        dd          d          t                                V  RdS )u  
    Генерация списка объектов Checks.

    :param n: Количество объектов для генерации.
    :param purchase_ids: Список идентификаторов покупок.
    :yield: Объект Checks.
    r   )Checks   d      )purchase_idamountpayment_methodN)r   r   r   r	   r
   rounduniformr}   )r   purchase_idsr   r   s       r   generate_check_datar      s       1XX 
 
fl333//33244
 
 
 	
 	
 	
 	

 
r   c              #      K   ddl m} t          |           D ]Z}t                      } |t	          j        |          |d         |d         |d         |d         |d         |d         	          V  [d
S )u  
    Генерация списка объектов HWID.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :yield: Объект HWID.
    r   )HWIDr   r   r   r   r   r   )r   r   r   r   r   r   r   N)r   r   r   r   r	   r
   )r   r   r   r   	pc_paramss        r   generate_hwid_datar      s       1XX 

 

*,,	dM(++,, .i(G$">2
 
 
 	
 	
 	
 	


 

r   c              #      K   ddl m} t          j                    }t	          |           D ]P} |t          j        |          t          d          t          |t          d          z
  |                    V  QdS )u  
    Генерация списка объектов Operation.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :yield: Объект Operation.
    r   )	Operation   r   r"   )r   operation_typeoperation_dateN)
r   r   r   r   r   r	   r
   r   r(   r   )r   r   r   r   r   s        r   generate_operation_datar      s       "!!!!!
,..C1XX 
 
iM(++(,,&sYC-@-@-@'@#FF
 
 
 	
 	
 	
 	

 
r   c              #     K   ddl m} t          j                    }t	          |           D ]U} |t          j        |          t          j        |          t          |t          d          z
  |                    V  VdS )ut  
    Генерация списка объектов Subscription.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Subscription.
    r   )Subscriptionr   r"   )r   r   subscription_timeN)	r   r   r   r   r   r	   r
   r(   r   )r   r   r   r   r   r   s         r   generate_subscription_datar     s       %$$$$$
,..C1XX 
 
lM(++=)))#	s0C0C0C*CSII
 
 
 	
 	
 	
 	

 
r   c              #     K   ddl m} t          j                    }t	          |           D ]U} |t          j        |          t          j        |          t          |t          d          z
  |                    V  VdS )uU  
    Генерация списка объектов Token.

    :param n: Количество объектов для генерации.
    :param user_ids: Список идентификаторов пользователей.
    :param hwid_ids: Список идентификаторов HWID.
    :yield: Объект Token.
    r   )Tokenr   r"   )r   hwid_id
last_loginN)	r   r   r   r   r   r	   r
   r(   r   )r   r   hwid_idsr   r   r   s         r   generate_token_datar     s       
,..C1XX 
 
eM(++M(++"3)<)<)<#<cBB
 
 
 	
 	
 	
 	

 
r   c              #   |  K   ddl m} g d}g d}g d}t          |           D ]}t          j        |           dt          dd           }| dt          j        |           } |t          j        |          t          d	d
          |t          j        |          dt          d           d          V  dS )u  
    Генерация списка объектов Version.

    :param n: Количество объектов для генерации.
    :param mod_ids: Список идентификаторов модификаций.
    :yield: Объект Version.
    r   )rN   )z1.0z1.1z2.0z3.0z4.0z5.0z6.0z7.0z8.0z9.0z10.0z11.0z12.0z13.0z14.0z15.0)AlphaBetarR   StableFinal)
u_   Первоначальный выпуск с базовой функциональностью.   Это обновление включает исправления и улучшения производительности.d   Новое крупное обновление с дополнительными функциями.uH   Исправлены ошибки предыдущих выпусков.u3   Конечный стабильный выпуск.ue   Это обновление содержит новые возможности и улучшения.u^   Сборка с исправлениями уязвимостей и обновлениями.u]   Новое обновление с новыми функциями и улучшениями.r   r   .	   r.   r      zhttp://new-version-
   z.com)r   version_numberversion_nameversion_descriptionversion_linkN)r   rN   r   r	   r
   r,   r   )	r   r   rN   version_prefixesversion_suffixesrZ   r   r   r   s	            r   generate_version_datar   ,  s        N  N  NFFF  L 1XX 

 

"M*:;;PPjA>N>NPP(LL6=9I+J+JLLg=))%a--% &l ; ;F}R/@/@FFF
 
 
 	
 	
 	
 	
	

 

r   )__doc__r	   r   r   r   r   r    r(   r,   r2   r@   rX   r[   r}   r   r   r   r   r   r   r   r   r   r   r    r   r   <module>r      s  	 	   ( ( ( ( ( ( ( (B B B  	A 	A 	A, , ,
e 
e 
e	I 	I 	I	J 	J 	J' ' '." " "  ,	8 	8 	8
 
 
&
 
 
 
 
 
$
 
 
 
 
 
*
 
 
"
 
 
$
 
 
$"
 "
 "
 "
 "
r   
Файл lib/__pycache__/orm.cpython-311.pyc:


    qf=                        d Z ddlZddlmZ  G d de          Z G d de          Z G d d	          Z G d
 de          Z G d de          Z	 G d de	          Z
 G d de	          Z G d de	          Z G d de	          Z G d de	          Z G d de	          Z G d de	          Z G d de	          Z G d d e	          Z G d! d"e	          ZdS )#u2  
Модуль для определения моделей ORM (Object-Relational Mapping).

Импорты:
    - Импортируются необходимые модули и библиотеки.

Классы:
    - FieldType: Перечисление типов данных для полей.
    - OperationType: Перечисление возможных типов операций (логин, логаут и т.д.)
    - Field: Класс для определения полей модели.
    - ModelMeta: Метакласс для динамического создания моделей.
    - Model: Базовый класс модели с методами для работы с БД (CRUD операции).

Примеры моделей:
    - Application: Модель приложения.
    - Users: Модель пользователей.
    - Modification: Модель модификаций.
    - Purchase, Checks, HWID, Operation, Subscription, Token, Version: Другие модели для различных данных.
    N)Enumc                   *    e Zd ZdZdZdZdZdZdZdZ	dS )		FieldTypeuZ   
    Перечисление типов данных для полей модели.
    INTSERIALVARCHARDATE	TIMESTAMPzDECIMAL(10,2)N)
__name__
__module____qualname____doc__r   r   r   r	   DATETIMEDECIMAL     ./home/server/python-orm-enikeev/orm/lib/orm.pyr   r      s8          CFGDHGGGr   r   c                   "    e Zd ZdZdZdZdZdZdS )OperationTypeu?   
    Перечисление типов операций.
    LOGINLOGOUTPURCHASEUPDATE_PROFILEN)r   r   r   r   r   r   r   r   r   r   r   r   r   #   s.          EFH%NNNr   r   c                       e Zd ZdZddZdS )Fieldu  
    Класс для определения поля модели.

    Атрибуты:
        - type: Тип данных поля.
        - primary_key: Является ли поле первичным ключом.
        - foreign_key: Внешний ключ, если есть.
        - max_length: Максимальная длина для строковых полей.
        - min_value: Минимальное значение для числовых полей.
        - max_value: Максимальное значение для числовых полей.
        - many_to_many: Является ли поле отношением many-to-many.
    FNc                     t          |t                    st          d          |j        | _        || _        || _        || _        || _        || _	        || _
        d S )Nz0Field type must be an instance of FieldType Enum)
isinstancer   
ValueErrorvaluetypeprimary_keyforeign_key
max_length	min_value	max_valuemany_to_many)selftype_r!   r"   r#   r$   r%   r&   s           r   __init__zField.__init__9   s`    %++ 	QOPPPK	&&$""(r   )FNNNNF)r   r   r   r   r)   r   r   r   r   r   ,   s2         	) 	) 	) 	) 	) 	)r   r   c                   ,     e Zd ZdZ fdZ fdZ xZS )	ModelMetau_   
    Метакласс для динамической генерации моделей.
    c                    |                     d          }|rt          j        d|          }|D ]\  }}}}	}
}	}}	}}	}}t          |          }t          |         }|rt          |          nd }|rt          |          nd }|rt          |          nd }t          |          }t          |||
||||          ||<   t                                          | |||          S )Nr   z(\w+): FieldType\.(\w+)(, primary_key=True)?(, foreign_key=\'(.+?)\')?(, max_length=(\d+))?(, min_value=(\d+))?(, max_value=(\d+))?(, many_to_many=True)?)	getrefindallboolr   intr   super__new__)clsnamebasesdct	docstringfield_definitions
field_name
field_typer!   _r"   r#   r$   r%   r&   field_type_enum	__class__s                   r   r3   zModelMeta.__new__H   s   GGI&&	 	C "
 m! ! AR C C|
JQQ
TUW`bcenp|";//"+J"70:DS___
.7AC	NNNT	.7AC	NNNT	#L11"'kS]_hjs  vB  #C  #CJwwsD%555r   c                     t          | d          si | _        n
| | j        |<   t          t          |                               |||           d S )N	_registry)hasattrr@   r2   r+   r)   )r4   r5   r6   r7   r>   s       r   r)   zModelMeta.__init__Y   sR    sK(( 	&CMM"%CM$i&&tUC88888r   )r   r   r   r   r3   r)   __classcell__)r>   s   @r   r+   r+   D   s[         6 6 6 6 6"9 9 9 9 9 9 9 9 9r   r+   c                       e Zd ZdZi Zg Zd Zed             Zed             Z	e
d             Zd Zd Zed             Zed	             Zd
 Zd ZdS )Modelu   
    Базовый класс для моделей. Определяет методы сохранения, удаления, обновления 
    и получения данных из базы данных.
    c                     |                                 D ]\  }}t          | ||           | j        j                                         D ]/\  }}t	          |t
                    r||vrt          | |d            0d S )N)itemssetattrr>   __dict__r   r   )r'   kwargskeyr   fields        r   r)   zModel.__init__h   s     ,,.. 	& 	&JCD#u%%%%.17799 	) 	)JC%'' )Cv,=,=c4(((	) 	)r   c           	      b   g }| j                                         D ]\  }}t          |t                    r | d|j         }|j        r| d|j         d}|j        r+|dz  }|t          j        | j	        
                                <   |j        r|d|j         z  }|                    |           |j        r~t          j                            | j	        
                                ||j                            d          d         |j                            d          d         d	d
         f           d| j	        
                                 dd                    |           d}|                                5 }|                    |           d	d	d	           d	S # 1 swxY w Y   d	S )u   
        Создание таблицы для модели.

        :param db: Объект Database для подключения к базе данных.
         z	 VARCHAR()z PRIMARY KEYz REFERENCES (r      NzCREATE TABLE IF NOT EXISTS  (, z);)rH   rF   r   r   r    r#   r!   rD   primary_keysr   lowerr"   appendr&   many_to_many_tablessplitjoin
get_cursorexecute)r4   dbfieldsattrr   	field_defquerycurs           r   create_tablezModel.create_tableo   sG    <--// 	Z 	ZKD%%'' Z#22ej22	# F#' E E%2B E E EI$ D/I?CE&s|'9'9';';<$ D!C0A!C!CCIi(((% Z-44cl6H6H6J6JDRWRcRiRijmRnRnopRqsx  tE  tK  tK  LO  tP  tP  QR  tS  TW  UW  TW  tX  6Y  Z  Z  Z[cl.@.@.B.B[[diiPVFWFW[[[]]__ 	KK	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	s   F$$F(+F(c                 r    t           j        D ])\  }}}}|                     |||t           j                   *dS )u   
        Создание таблиц для отношений many-to-many.

        :param db: Объект Database для подключения к базе данных.
        N)rD   rW   create_many_to_many_tablerT   )r4   r\   table1field1table2field2s         r   create_many_to_many_tablesz Model.create_many_to_many_tables   sM     /4.G 	R 	R*FFFF))"ffe>PQQQQ	R 	Rr   c                     | d| }||         }||         }d| d| d| d| d| d| d| d| d| d	}|                                  5 }|                    |           d
d
d
           d
S # 1 swxY w Y   d
S )u  
        Статический метод для создания таблицы many-to-many.

        :param db: Объект Database для подключения к базе данных.
        :param table1: Первая таблица.
        :param table2: Вторая таблица.
        :param primary_keys: Словарь первичных ключей.
        r<   z$
        CREATE TABLE IF NOT EXISTS z (
            z INT REFERENCES rO   z),
            z),
            PRIMARY KEY (rS   z)
        );
        N)rZ   r[   )	r\   re   rg   rT   
table_name	table1_pk	table2_pkr`   ra   s	            r   rd   zModel.create_many_to_many_table   s9    ))))
 (	 (	$.  (. 1:    )/  2;  $	  (1	   ]]__ 	KK	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	s   
A--A14A1c                 D   g }g }| j         j                                        D ]z\  }}t          |t                    r`t          | |          }t          |t                    r|j        }||j        rP|	                    |           |	                    |           {||fS )u   
        Извлечение значений полей для вставки или обновления.

        :return: Список имен полей и список значений полей.
        )
r>   rH   rF   r   r   getattrr   r   r!   rV   )r'   columnsvaluesr^   rK   r   s         r   extract_field_valueszModel.extract_field_values   s     >288:: 	% 	%KD%%'' %d++eT** (!KE=U%6=t$$$e$$$r   c                    |                                  \  }}|st          d          d                    |          }d                    dgt          |          z            }d| j        j                                         d| d| d}|                                5 }|                    ||           |	                                }t          ||          D ]\  }	}
t          | |	|
           	 ddd           dS # 1 swxY w Y   dS )	u   
        Сохранение текущего объекта модели в базу данных.

        :param db: Объект Database для подключения к базе данных.
        zNo fields found to insert.rS   z%szINSERT INTO rR   z
) VALUES (z) RETURNING *;N)rr   r   rY   lenr>   r   rU   rZ   r[   fetchoneziprG   )r'   r\   rp   rq   column_namesplaceholdersr`   ra   returned_valuesrJ   r   s              r   savez
Model.save   sX    3355 	;9:::yy))yy$#g,,!677vt~6<<>>vv,vvZfvvv]]__ 	*KKv&&&!llnnO!'?;; * *
Uc5))))*	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	* 	*s    AD  DDc                    d| j                                          d}|                                5 }|                    |           |                                }g }|D ]I} | di t          t          d |j        D             |                    }|                    |           J|cddd           S # 1 swxY w Y   dS )u   
        Получение всех записей из таблицы.

        :param db: Объект Database для подключения к базе данных.
        :return: Список объектов модели.
        SELECT * FROM ;c                     g | ]
}|d          S r   r   .0cols     r   
<listcomp>z!Model.get_all.<locals>.<listcomp>       %H%H%Hc!f%H%H%Hr   Nr   )	r   rU   rZ   r[   fetchalldictrv   descriptionrV   )r4   r\   r`   ra   recordsresultsrecordobjs           r   get_allzModel.get_all   s    9!3!3!5!5888]]__ 	KKllnnGG! $ $cSSD%H%H%H%H%H&!Q!QRRSSs####	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	s   A9B88B<?B<c                 0   d |                                 D             }d| j                                         dd                    |           }|                                5 }|                    |t          |                                                     |                                }g }|D ]I} | di t          t          d |j        D             |                    }	|                    |	           J|cddd           S # 1 swxY w Y   dS )ux  
        Фильтрация записей по заданным условиям.

        :param db: Объект Database для подключения к базе данных.
        :param kwargs: Словарь условий фильтрации.
        :return: Список объектов модели, соответствующих условиям.
        c                     g | ]}| d S  = %sr   r   rJ   s     r   r   z Model.filter.<locals>.<listcomp>   s    ===mmm===r   r|    WHERE z AND c                     g | ]
}|d          S r   r   r   s     r   r   z Model.filter.<locals>.<listcomp>   r   r   Nr   )keysr   rU   rY   rZ   r[   tuplerq   r   r   rv   r   rV   )
r4   r\   rI   
conditionsr`   ra   r   r   r   r   s
             r   filterzModel.filter   sR    >=v{{}}===
X!3!3!5!5XXgll:>V>VXX]]__ 	KKuV]]__55666llnnGG! $ $cSSD%H%H%H%H%H&!Q!QRRSSs####	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	s   %BDDDc                 P   t           j        | j        j                                                 }d| j        j                                         d| d}|                                5 }|                    |t          | |          f           ddd           dS # 1 swxY w Y   dS )u   
        Удаление текущего объекта модели из базы данных.

        :param db: Объект Database для подключения к базе данных.
        zDELETE FROM r   r   N)rD   rT   r>   r   rU   rZ   r[   ro   )r'   r\   pk_namer`   ra   s        r   deletezModel.delete   s     $T^%<%B%B%D%DEUt~6<<>>UUwUUU]]__ 	:KKg 6 68999	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: 	:s   (&BB"Bc                    t           j        | j        j                                                 }d                    d |                                D                       }d| j        j                                         d| d| d}t          |                                          t          | |          fz   }|
                                5 }|                    ||           |                                D ]\  }}	t          | ||	           d| j        j                                         d| d}|                    |t          | |          f           |                                }
|
r6t          d |j        D             |
          D ]\  }}	t          | ||	           d	d	d	           d	S # 1 swxY w Y   d	S )
u<  
        Обновление полей текущего объекта модели в базе данных.

        :param db: Объект Database для подключения к базе данных.
        :param kwargs: Словарь полей и значений для обновления.
        rS   c                     g | ]}| d S r   r   r   s     r   r   z Model.update.<locals>.<listcomp>  s    GGG#3GGGr   zUPDATE z SET r   r   r|   c                     g | ]
}|d          S r   r   r   s     r   r   z Model.update.<locals>.<listcomp>  s    &I&I&I#s1v&I&I&Ir   N)rD   rT   r>   r   rU   rY   r   r   rq   ro   rZ   r[   rF   rG   ru   rv   r   )r'   r\   rI   r   
set_clauser`   rq   ra   rJ   r   updated_records              r   updatezModel.update  s    $T^%<%B%B%D%DEYYGGGGGHH
a$.17799aa
aaSZaaav}}''74+A+A*CC]]__ 	.KKv&&&$llnn * *
Uc5)))) \T^%<%B%B%D%D[[W[[[EKKg 6 68999 \\^^N ."%&I&I&I&I&I>"Z"Z . .JCD#u----	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	. 	.s   CF44F8;F8N)r   r   r   r   rT   rW   r)   classmethodrb   ri   staticmethodrd   rr   rz   r   r   r   r   r   r   r   rD   rD   `   s          L) ) )   [4 R R [R   \,  &* * **   ["   [(	: 	: 	:. . . . .r   rD   )	metaclassc                       e Zd ZdZdS )Applicationzd
    app_id: FieldType.SERIAL, primary_key=True
    app_name: FieldType.VARCHAR, max_length=255
    Nr   r   r   r   r   r   r   r   r     s           r   r   c                       e Zd ZdZdS )Usersa  
    user_id: FieldType.SERIAL, primary_key=True
    full_name: FieldType.VARCHAR, max_length=100
    email: FieldType.VARCHAR, max_length=255
    password: FieldType.VARCHAR, max_length=100
    registration_date: FieldType.DATE
    app_availability: FieldType.INT, foreign_key='application(app_id)', min_value=1, max_value=100
    subscriptions: FieldType.INT, foreign_key='modification(mod_id)', many_to_many=True
    Nr   r   r   r   r   r   $  s           r   r   c                       e Zd ZdZdS )Modificationz
    mod_id: FieldType.SERIAL, primary_key=True
    mod_name: FieldType.VARCHAR, max_length=100
    mod_desc: FieldType.VARCHAR, max_length=255
    app_id: FieldType.INT, foreign_key='application(app_id)', min_value=1, max_value=100
    Nr   r   r   r   r   r   /             r   r   c                       e Zd ZdZdS )Purchasea
  
    purchase_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    purchase_date: FieldType.DATE
    Nr   r   r   r   r   r   7  r   r   r   c                       e Zd ZdZdS )Checksz
    check_id: FieldType.SERIAL, primary_key=True
    purchase_id: FieldType.INT, foreign_key='purchase(purchase_id)', min_value=1, max_value=100
    amount: FieldType.DECIMAL
    payment_method: FieldType.VARCHAR, max_length=50
    Nr   r   r   r   r   r   ?  r   r   r   c                       e Zd ZdZdS )HWIDa  
    hwid_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    processor: FieldType.VARCHAR, max_length=50
    videocard: FieldType.VARCHAR, max_length=50
    os_version: FieldType.VARCHAR, max_length=50
    os_type: FieldType.VARCHAR, max_length=50
    disks: FieldType.VARCHAR, max_length=50
    network_card: FieldType.VARCHAR, max_length=50
    Nr   r   r   r   r   r   G  s        	 	 	 	r   r   c                       e Zd ZdZdS )	Operationz
    operation_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    operation_type: FieldType.VARCHAR, max_length=100
    operation_date: FieldType.DATETIME
    Nr   r   r   r   r   r   S  r   r   r   c                       e Zd ZdZdS )Subscriptiona  
    subscription_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    subscription_time: FieldType.DATETIME
    Nr   r   r   r   r   r   [  r   r   r   c                       e Zd ZdZdS )Tokena  
    token_id: FieldType.SERIAL, primary_key=True
    user_id: FieldType.INT, foreign_key='users(user_id)', min_value=1, max_value=100
    hwid_id: FieldType.INT, foreign_key='hwid(hwid_id)', min_value=1, max_value=100
    last_login: FieldType.DATETIME
    Nr   r   r   r   r   r   c  r   r   r   c                       e Zd ZdZdS )Versionaq  
    version_id: FieldType.SERIAL, primary_key=True
    mod_id: FieldType.INT, foreign_key='modification(mod_id)', min_value=1, max_value=100
    version_number: FieldType.INT, min_value=1, max_value=10
    version_name: FieldType.VARCHAR, max_length=50
    version_description: FieldType.VARCHAR, max_length=255
    version_link: FieldType.VARCHAR, max_length=255
    Nr   r   r   r   r   r   k  s           r   r   )r   r.   enumr   r   r   r   r    r+   rD   r   r   r   r   r   r   r   r   r   r   r   r   r   <module>r      s   ( 
			      	 	 	 	 	 	 	 	& & & & &D & & &) ) ) ) ) ) ) )09 9 9 9 9 9 9 98{. {. {. {. {.i {. {. {. {.|    %   	 	 	 	 	E 	 	 	    5       u       U   
 
 
 
 
5 
 
 
           5       E       e     r   
Файл lib/__pycache__/db.cpython-311.pyc:


    qf4                     `    d Z ddlZddlmZ ddlmZ ddlmZ ddlZddlZ G d d          Z	dS )u  
Модуль для работы с базой данных PostgreSQL.

Импорты:
    - Импортируются необходимые модули и библиотеки.

Классы:
    - Database: Класс для работы с базой данных PostgreSQL.

Методы:
    - __init__: Инициализация объекта базы данных и проверка её существования.
    - __enter__: Контекстный менеджер для открытия соединения с базой данных.
    - __exit__: Закрытие соединения с базой данных.
    - _ensure_database: Проверка существования и создание базы данных.
    - get_connection: Контекстный менеджер для получения соединения.
    - get_cursor: Контекстный менеджер для получения курсора.
    - create_db: Создание новой базы данных.
    - drop_db: Удаление базы данных.
    - clone_schema: Клонирование схемы из одной базы данных в другую.
    - create_dump: Создание дампа базы данных или таблицы.
    - restore_dump: Восстановление данных из дампа.
    - delete_all_data: Удаление всех данных из таблицы.
    - replace_all_data: Замена всех данных в таблице.
    N)sql)ISOLATION_LEVEL_AUTOCOMMIT)contextmanagerc                       e Zd ZdZddZd Zd Zd	 Zed
             Z	ed             Z
d Zd Zd ZddZddZd Zd Zd ZdS )Databaseuz  
    Класс для работы с базой данных PostgreSQL, включающий методы для создания, удаления, клонирования базы данных и работы с дампами.

    Атрибуты:
    - dbname (str): Имя базы данных.
    - user (str): Пользователь базы данных. По умолчанию 'postgres'.
    - password (str): Пароль пользователя базы данных.
    - host (str): Хост базы данных. По умолчанию 'localhost'.
    - port (int): Порт базы данных. По умолчанию 5432.

    Методы:
    - __init__: Инициализация объекта базы данных и проверка её существования.
    - __enter__: Контекстный менеджер для открытия соединения с базой данных.
    - __exit__: Закрытие соединения с базой данных.
    - _ensure_database: Проверка существования и создание базы данных.
    - get_connection: Контекстный менеджер для получения соединения.
    - get_cursor: Контекстный менеджер для получения курсора.
    - create_db: Создание новой базы данных.
    - drop_db: Удаление базы данных.
    - clone_schema: Клонирование схемы из одной базы данных в другую.
    - create_dump: Создание дампа базы данных или таблицы.
    - restore_dump: Восстановление данных из дампа.
    - delete_all_data: Удаление всех данных из таблицы.
    - replace_all_data: Замена всех данных в таблице.
    postgressecret6g2h2	localhost8  c                 t    || _         || _        || _        || _        || _        |                                  dS )u  
        Инициализация объекта базы данных.

        :param dbname: Имя базы данных.
        :param user: Пользователь базы данных. По умолчанию 'postgres'.
        :param password: Пароль пользователя. По умолчанию 'secret6g2h2'.
        :param host: Хост базы данных. По умолчанию 'localhost'.
        :param port: Порт базы данных. По умолчанию 5432.
        N)dbnameuserpasswordhostport_ensure_database)selfr   r   r   r   r   s         -/home/server/python-orm-enikeev/orm/lib/db.py__init__zDatabase.__init__<   sA     	 		 	    c                     t          j        | j        | j        | j        | j        | j                  | _        d| j        _        | S )uj   
        Открытие соединения с базой данных.

        :return: self
        r   r   r   r   r   T)	psycopg2connectr   r   r   r   r   conn
autocommit)r   s    r   	__enter__zDatabase.__enter__O   sI     $DKdiRVR_fjfovzv  A  A  A	#	r   c                 8    | j                                          dS )uS   
        Закрытие соединения с базой данных.
        N)r   close)r   exc_type	exc_value	tracebacks       r   __exit__zDatabase.__exit__Y   s     		r   c                    t          j        d| j        | j        | j        | j                  }d|_        |                                }|                    d| j	         d           |
                                }|s|                    d| j	         d           |                                 |                                 dS )	u   
        Проверка существования базы данных и создание её при отсутствии.
        r   r   Tz+SELECT 1 FROM pg_database WHERE datname = ''zCREATE DATABASE ""N)r   r   r   r   r   r   r   cursorexecuter   fetchoner   )r   r   r'   existss       r   r   zDatabase._ensure_database_   s     z	DM`d`iptpyzzzST[SSSTTT"" 	?NN=t{===>>>

r   c              #      K   t          j        | j        | j        | j        | j        | j                  }d|_        	 |V  |                                 dS # |                                 w xY w)u   
        Контекстный менеджер для получения соединения с базой данных.

        :yield: Соединение с базой данных.
        r   TN)	r   r   r   r   r   r   r   r   r   )r   r   s     r   get_connectionzDatabase.get_connectiono   si       t{T]aeajquqz{{{	JJJJJLLLLLDJJLLLLs   A A-c              #   p  K   |                                  5 }|                                }	 |V  |                                 n(# t          $ r}|                                 |d}~ww xY w	 |                                 n# |                                 w xY w	 ddd           dS # 1 swxY w Y   dS )u   
        Контекстный менеджер для получения курсора.

        :yield: Курсор для выполнения SQL-запросов.
        N)r,   r'   commit	Exceptionrollbackr   )r   r   r'   es       r   
get_cursorzDatabase.get_cursor}   s         "" 		d[[]]F    
 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		sF   B+AB
A+A&&A++B/B+BB++B/2B/c                 8   t          j        d| j        | j        | j        | j                  }|                    t                     	 |                                5 }t          j
        d                              t          j        |                    }|                    |           ddd           n# 1 swxY w Y   n)# t          $ r}t          d|            Y d}~nd}~ww xY w|                                 dS # |                                 w xY w)u   
        Создание новой базы данных с заданным именем.

        :param db_name: Имя новой базы данных.
        r   r   zCREATE DATABASE {}NzError creating database: )r   r   r   r   r   r   set_isolation_levelr   r'   r   SQLformat
Identifierr(   r/   printr   )r   db_namer   r'   create_db_sqlr1   s         r   	create_dbzDatabase.create_db   sM    z	DM`d`iptpyzzz  !;<<<	 .& #(< = = D DS^T[E\E\ ] ]}---. . . . . . . . . . . . . . .  	3 	3 	31a1122222222	3 JJLLLLLDJJLLLLsU   	C AB8,C 8B<<C ?B< C D 
C*C% D %C**D Dc                    t          j        d| j        | j        | j        | j                  5 }|                    t                     |                                5 }|	                    t          j        d          |g           ddd           n# 1 swxY w Y   ddd           n# 1 swxY w Y   t          j        d| j        | j        | j        | j                  }|                    t                     	 |                                5 }t          j        d                              t          j        |                    }|	                    |           ddd           n# 1 swxY w Y   n)# t          $ r}t          d|            Y d}~nd}~ww xY w|                                 dS # |                                 w xY w)u   
        Удаление базы данных с заданным именем.

        :param db_name: Имя базы данных для удаления.
        r   r   zcSELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname=%s AND pid <> pg_backend_pid()NzDROP DATABASE IF EXISTS {}zError dropping database: )r   r   r   r   r   r   r4   r   r'   r(   r   r5   r6   r7   r/   r8   r   )r   r9   r   r'   drop_db_sqlr1   s         r   drop_dbzDatabase.drop_db   su    Zdi$-^b^gnrnwxxx 	  }A$$%?@@@ &G  B  C  CI                	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 z	DM`d`iptpyzzz  !;<<<	 ,&!g&BCCJJ3>ZaKbKbcc{+++, , , , , , , , , , , , , , ,  	3 	3 	31a1122222222	3 JJLLLLLDJJLLLLs   /B**BB*B	B*B	B**B.1B.=E8 AE, E8 ,E00E8 3E04E8 7F7 8
FFF7 FF7 7Gc                 
   t          j        || j        | j        | j        | j                  }t          j        || j        | j        | j        | j                  }d|_        d|_        |                                }|                                }|                    d           |	                                }|D ]v}|                    d|d          d           |	                                }	d
                    d |	D                       }
|                    d	|d          d
|
 d           w|                                 |                                 |                                 |                                 dS )u  
        Клонирование схемы из исходной базы данных в целевую базу данных.

        :param source_db: Имя исходной базы данных.
        :param target_db: Имя целевой базы данных.
        r   TzNSELECT table_name FROM information_schema.tables WHERE table_schema = 'public'zRSELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'r   r%   , c                 4    g | ]}|d           d|d          S )r        ).0cols     r   
<listcomp>z)Database.clone_schema.<locals>.<listcomp>   s.    $M$M$McA%9%9Q%9%9$M$M$Mr   zCREATE TABLE  ()N)r   r   r   r   r   r   r   r'   r(   fetchalljoinr   )r   	source_db	target_dbsource_conntarget_conn
source_cur
target_curtablestablecolumnscolumns_defs              r   clone_schemazDatabase.clone_schema   s    &idiRVR_fjfovzv  A  A  A&idiRVR_fjfovzv  A  A  A!%!% ''))
 ''))
oppp$$&& 	K 	KEtyz{t|  A  A  A ))++G))$M$MW$M$M$MNNKIuQxII;IIIJJJJr   Nc                     t           j                                        }| j        |d<   dd| j        dt          | j                  d| j        ddd|| j        g}|r|d	|gz  }t          j
        ||d
           dS )u  
        Создание дампа базы данных или заданной таблицы с использованием pg_dump.

        :param output_file: Имя файла для сохранения дампа.
        :param table_name: Имя таблицы для создания дампа (если None, создается дамп всей базы данных).
        
PGPASSWORDpg_dump-h-p-Uz-Fcz-f-tTenvcheckNosenvironcopyr   r   strr   r   r   
subprocessrun)r   output_file
table_namer`   cmds        r   create_dumpzDatabase.create_dump   s     joo ML $)#di..$)#+K
  	&D*%%Cs4000000r   c           
          t           j                                        }| j        |d<   dd| j        dt          | j                  d| j        d| j        dg
}|r|d|gz  }||gz  }t          j
        ||d	
           dS )uq  
        Восстановление данных в базе данных из дампа с использованием pg_restore.

        :param input_file: Имя файла дампа.
        :param table_name: Имя таблицы для восстановления (если None, восстанавливается вся база данных).
        rX   
pg_restorerZ   r[   r\   z-dz-cr^   Tr_   Nrb   )r   
input_filerj   r`   rk   s        r   restore_dumpzDatabase.restore_dump   s     joo ML $)#di..$)$+
  	&D*%%C
|s4000000r   c                     |                                  5 }|                    d           ddd           dS # 1 swxY w Y   dS )uf   
        Удаляет все данные из всех таблиц базы данных.
        aI  
                DO $$ DECLARE
                    r RECORD;
                BEGIN
                    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP
                        EXECUTE 'DELETE FROM ' || quote_ident(r.tablename);
                    END LOOP;
                END $$;
            Nr2   r(   )r   r'   s     r   delete_all_datazDatabase.delete_all_data  s     __ 		&NN    		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		s   8<<c                     |                                  5 }|                    d|            ddd           dS # 1 swxY w Y   dS )u   
        Удаление всех данных из указанной таблицы.

        :param table_name: Имя таблицы.
        DELETE FROM Nrr   )r   rj   r'   s      r   rs   zDatabase.delete_all_data  s     __ 	8&NN6*66777	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8 	8s   ;??c                    |                                  5 }|                    d|            |D ]y}d                    |                                          }d                    d |                                D                       }|                    d| d| d| d           z	 ddd           dS # 1 swxY w Y   dS )	u   
        Замена всех данных в указанной таблице.

        :param table_name: Имя таблицы.
        :param data: Новые данные для вставки.
        ru   r@   c                 4    g | ]}d t          |           d S )r%   )rf   )rE   vs     r   rG   z-Database.replace_all_data.<locals>.<listcomp>+  s&    #H#H#HaMAMMM#H#H#Hr   zINSERT INTO rH   z
) VALUES (rI   N)r2   r(   rK   keysvalues)r   rj   datar'   rowrT   rz   s          r   replace_all_datazDatabase.replace_all_data   s,    __ 	Z&NN6*66777 Z Z))CHHJJ//#H#H3::<<#H#H#HIIXjXXGXXvXXXYYYYZ	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Z 	Zs   BB88B<?B<)r   r	   r
   r   )N)__name__
__module____qualname____doc__r   r   r#   r   r   r,   r2   r;   r>   rV   rl   rp   rs   r}   rD   r   r   r   r   !   s        4       &          ^   ^"  "  2  <1 1 1 101 1 1 12  8 8 8Z Z Z Z Zr   r   )
r   r   r   psycopg2.extensionsr   
contextlibr   rg   rc   r   rD   r   r   <module>r      s    2        : : : : : : % % % % % %     				KZ KZ KZ KZ KZ KZ KZ KZ KZ KZr   
Файл lib/plot_utils.py:

"""
Модуль для построения и сохранения графиков.

Импорты:
    - Импортируется модуль matplotlib.pyplot для построения графиков.

Функции:
    - save_plot: Построение и сохранение графика с несколькими линиями.
"""

import matplotlib.pyplot as plt

def save_plot(x_values, y_values, labels, title, xlabel, ylabel, filename, formats=('png',), figsize=(10, 6)):
    """
    Построение и сохранение графика с несколькими линиями.

    :param x_values: Список значений по оси X.
    :param y_values: Список списков значений по оси Y для каждой линии.
    :param labels: Список меток для каждой линии.
    :param title: Название графика.
    :param xlabel: Подпись оси X.
    :param ylabel: Подпись оси Y.
    :param filename: Имя файла для сохранения графика (без расширения).
    :param formats: Форматы для сохранения (например, ['png', 'svg']).
    :param figsize: Размер фигуры графика.
    """
    
    linestyles = ['-', '--', '-.', ':']
    markers = ['o', 's', 'D', '^', 'v', '<', '>', 'p', '*']
    plt.figure(figsize=figsize)

    for i, (y, label) in enumerate(zip(y_values, labels)):
        linestyle = linestyles[i % len(linestyles)]
        marker = markers[i % len(markers)] if len(x_values) > 10 else None
        plt.plot(x_values, y, label=label, linestyle=linestyle, marker=marker)

    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend()
    plt.grid(True)

    for fmt in formats:
        plt.savefig(f'{filename}.{fmt}')
    
    plt.close()
Файл lib/db.py:

"""
Модуль для работы с базой данных PostgreSQL.

Импорты:
    - Импортируются необходимые модули и библиотеки.

Классы:
    - Database: Класс для работы с базой данных PostgreSQL.

Методы:
    - __init__: Инициализация объекта базы данных и проверка её существования.
    - __enter__: Контекстный менеджер для открытия соединения с базой данных.
    - __exit__: Закрытие соединения с базой данных.
    - _ensure_database: Проверка существования и создание базы данных.
    - get_connection: Контекстный менеджер для получения соединения.
    - get_cursor: Контекстный менеджер для получения курсора.
    - create_db: Создание новой базы данных.
    - drop_db: Удаление базы данных.
    - clone_schema: Клонирование схемы из одной базы данных в другую.
    - create_dump: Создание дампа базы данных или таблицы.
    - restore_dump: Восстановление данных из дампа.
    - delete_all_data: Удаление всех данных из таблицы.
    - replace_all_data: Замена всех данных в таблице.
"""

import psycopg2
from psycopg2 import sql
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
from contextlib import contextmanager
import subprocess
import os

class Database:
    """
    Класс для работы с базой данных PostgreSQL, включающий методы для создания, удаления, клонирования базы данных и работы с дампами.

    Атрибуты:
    - dbname (str): Имя базы данных.
    - user (str): Пользователь базы данных. По умолчанию 'postgres'.
    - password (str): Пароль пользователя базы данных.
    - host (str): Хост базы данных. По умолчанию 'localhost'.
    - port (int): Порт базы данных. По умолчанию 5432.

    Методы:
    - __init__: Инициализация объекта базы данных и проверка её существования.
    - __enter__: Контекстный менеджер для открытия соединения с базой данных.
    - __exit__: Закрытие соединения с базой данных.
    - _ensure_database: Проверка существования и создание базы данных.
    - get_connection: Контекстный менеджер для получения соединения.
    - get_cursor: Контекстный менеджер для получения курсора.
    - create_db: Создание новой базы данных.
    - drop_db: Удаление базы данных.
    - clone_schema: Клонирование схемы из одной базы данных в другую.
    - create_dump: Создание дампа базы данных или таблицы.
    - restore_dump: Восстановление данных из дампа.
    - delete_all_data: Удаление всех данных из таблицы.
    - replace_all_data: Замена всех данных в таблице.
    """

    def __init__(self, dbname, user='postgres', password='secret6g2h2', host='localhost', port=5432):
        """
        Инициализация объекта базы данных.

        :param dbname: Имя базы данных.
        :param user: Пользователь базы данных. По умолчанию 'postgres'.
        :param password: Пароль пользователя. По умолчанию 'secret6g2h2'.
        :param host: Хост базы данных. По умолчанию 'localhost'.
        :param port: Порт базы данных. По умолчанию 5432.
        """
        self.dbname = dbname
        self.user = user
        self.password = password
        self.host = host
        self.port = port

        # Проверка существования и создание базы данных
        self._ensure_database()

    def __enter__(self):
        """
        Открытие соединения с базой данных.

        :return: self
        """
        self.conn = psycopg2.connect(dbname=self.dbname, user=self.user, password=self.password, host=self.host, port=self.port)
        self.conn.autocommit = True
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        """
        Закрытие соединения с базой данных.
        """
        self.conn.close()

    def _ensure_database(self):
        """
        Проверка существования базы данных и создание её при отсутствии.
        """
        conn = psycopg2.connect(dbname='postgres', user=self.user, password=self.password, host=self.host, port=self.port)
        conn.autocommit = True
        cursor = conn.cursor()
        
        cursor.execute(f"SELECT 1 FROM pg_database WHERE datname = '{self.dbname}'")
        exists = cursor.fetchone()
        if not exists:
            cursor.execute(f'CREATE DATABASE "{self.dbname}"')
        
        cursor.close()
        conn.close()

    @contextmanager
    def get_connection(self):
        """
        Контекстный менеджер для получения соединения с базой данных.

        :yield: Соединение с базой данных.
        """
        conn = psycopg2.connect(dbname=self.dbname, user=self.user, password=self.password, host=self.host, port=self.port)
        conn.autocommit = True
        try:
            yield conn
        finally:
            conn.close()

    @contextmanager
    def get_cursor(self):
        """
        Контекстный менеджер для получения курсора.

        :yield: Курсор для выполнения SQL-запросов.
        """
        with self.get_connection() as conn:
            cursor = conn.cursor()
            try:
                yield cursor
                conn.commit()
            except Exception as e:
                conn.rollback()
                raise e
            finally:
                cursor.close()

    def create_db(self, db_name):
        """
        Создание новой базы данных с заданным именем.

        :param db_name: Имя новой базы данных.
        """
        conn = psycopg2.connect(dbname='postgres', user=self.user, password=self.password, host=self.host, port=self.port)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        try:
            with conn.cursor() as cursor:
                create_db_sql = sql.SQL("CREATE DATABASE {}").format(sql.Identifier(db_name))
                cursor.execute(create_db_sql)
        except Exception as e:
            print(f"Error creating database: {e}")
        finally:
            conn.close()

    def drop_db(self, db_name):
        """
        Удаление базы данных с заданным именем.

        :param db_name: Имя базы данных для удаления.
        """
        with psycopg2.connect(dbname='postgres', user=self.user, password=self.password, host=self.host, port=self.port) as conn:
            conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
            with conn.cursor() as cursor:
                cursor.execute(
                    sql.SQL("SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname=%s AND pid <> pg_backend_pid()"),
                    [db_name]
                )

        conn = psycopg2.connect(dbname='postgres', user=self.user, password=self.password, host=self.host, port=self.port)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        try:
            with conn.cursor() as cursor:
                drop_db_sql = sql.SQL("DROP DATABASE IF EXISTS {}").format(sql.Identifier(db_name))
                cursor.execute(drop_db_sql)
        except Exception as e:
            print(f"Error dropping database: {e}")
        finally:
            conn.close()

    def clone_schema(self, source_db, target_db):
        """
        Клонирование схемы из исходной базы данных в целевую базу данных.

        :param source_db: Имя исходной базы данных.
        :param target_db: Имя целевой базы данных.
        """
        source_conn = psycopg2.connect(dbname=source_db, user=self.user, password=self.password, host=self.host, port=self.port)
        target_conn = psycopg2.connect(dbname=target_db, user=self.user, password=self.password, host=self.host, port=self.port)
        
        source_conn.autocommit = True
        target_conn.autocommit = True
        
        source_cur = source_conn.cursor()
        target_cur = target_conn.cursor()

        source_cur.execute("""SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'""")
        tables = source_cur.fetchall()

        for table in tables:
            source_cur.execute(f"SELECT column_name, data_type FROM information_schema.columns WHERE table_name = '{table[0]}'")
            columns = source_cur.fetchall()
            columns_def = ", ".join([f"{col[0]} {col[1]}" for col in columns])
            target_cur.execute(f"CREATE TABLE {table[0]} ({columns_def})")

        source_cur.close()
        target_cur.close()
        source_conn.close()
        target_conn.close()

    def create_dump(self, output_file, table_name=None):
        """
        Создание дампа базы данных или заданной таблицы с использованием pg_dump.

        :param output_file: Имя файла для сохранения дампа.
        :param table_name: Имя таблицы для создания дампа (если None, создается дамп всей базы данных).
        """
        env = os.environ.copy()
        env['PGPASSWORD'] = self.password

        cmd = [
            'pg_dump',
            '-h', self.host,
            '-p', str(self.port),
            '-U', self.user,
            '-F', 'c',
            '-f', output_file,
            self.dbname
        ]
        if table_name:
            cmd += ['-t', table_name]

        subprocess.run(cmd, env=env, check=True)

    def restore_dump(self, input_file, table_name=None):
        """
        Восстановление данных в базе данных из дампа с использованием pg_restore.

        :param input_file: Имя файла дампа.
        :param table_name: Имя таблицы для восстановления (если None, восстанавливается вся база данных).
        """
        env = os.environ.copy()
        env['PGPASSWORD'] = self.password

        cmd = [
            'pg_restore',
            '-h', self.host,
            '-p', str(self.port),
            '-U', self.user,
            '-d', self.dbname,
            '-c',  # Очищает базу данных перед восстановлением
        ]
        if table_name:
            cmd += ['-t', table_name]

        cmd += [input_file]

        subprocess.run(cmd, env=env, check=True)

    def delete_all_data(self):
        """
        Удаляет все данные из всех таблиц базы данных.
        """
        with self.get_cursor() as cursor:
            cursor.execute("""
                DO $$ DECLARE
                    r RECORD;
                BEGIN
                    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP
                        EXECUTE 'DELETE FROM ' || quote_ident(r.tablename);
                    END LOOP;
                END $$;
            """)

    def delete_all_data(self, table_name):
        """
        Удаление всех данных из указанной таблицы.

        :param table_name: Имя таблицы.
        """
        with self.get_cursor() as cursor:
            cursor.execute(f"DELETE FROM {table_name}")

    def replace_all_data(self, table_name, data):
        """
        Замена всех данных в указанной таблице.

        :param table_name: Имя таблицы.
        :param data: Новые данные для вставки.
        """
        with self.get_cursor() as cursor:
            cursor.execute(f"DELETE FROM {table_name}")
            for row in data:
                columns = ', '.join(row.keys())
                values = ', '.join([f"'{str(v)}'" for v in row.values()])
                cursor.execute(f"INSERT INTO {table_name} ({columns}) VALUES ({values})")

Файл tests/test_orm.py:

"""
Этот файл содержит тесты для проверки корректности работы ORM-моделей (Object-Relational Mapping) и вспомогательных функций. Тесты используют библиотеку pytest для организации тестов, фикстур и выполнения assertion.

Импорты:
    sys, os: для добавления пути до модулей проекта.
    pytest: для организации тестов и фикстур.
    datetime: для работы с датой и временем.
    Модули и функции проекта: импорт объектов базы данных, генераторов данных и моделей ORM.
    
Фикстуры:
    db: Фикстура для управления жизненным циклом тестовой базы данных.
    setup_and_teardown: Автоматическая фикстура для создания таблиц перед каждым тестом и удаления данных после выполнения теста.
    
Тесты:
    test_application_insert: Проверка вставки и получения данных для модели Application.
    test_users_insert: Проверка вставки и получения данных для модели Users.
    test_modification_insert: Проверка вставки и получения данных для модели Modification.
    test_purchase_insert: Проверка вставки и получения данных для модели Purchase.
    test_checks_insert: Проверка вставки и получения данных для модели Checks.
    test_hwid_insert: Проверка вставки и получения данных для модели HWID.
    test_operation_insert: Проверка вставки и получения данных для модели Operation.
    test_subscription_insert: Проверка вставки и получения данных для модели Subscription.
    test_token_insert: Проверка вставки и получения данных для модели Token.
    test_version_insert: Проверка вставки и получения данных для модели Version.
    test_many_to_many_insert: Проверка вставки и получения данных для таблицы many-to-many между моделями Users и Modification.
    test_generate_data: Проверка генерации и вставки данных для всех моделей.
    test_filter_method: Проверка метода фильтрации данных для модели Users.
    test_update_method: Проверка метода обновления данных для модели Users.
    test_delete_method: Проверка метода удаления данных для модели Users.
"""

import sys
import os

# Добавляем путь к родительской директории для корректного импорта модулей
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import pytest
from datetime import datetime
from lib.data_generator import (
    generate_application_data,
    generate_user_data,
    generate_modification_data,
    generate_purchase_data,
    generate_check_data,
    generate_hwid_data,
    generate_operation_data,
    generate_subscription_data,
    generate_token_data,
    generate_version_data
)
from lib.db import Database
from lib.orm import (
    Application,
    Users,
    Modification,
    Purchase,
    Checks,
    HWID,
    Operation,
    Subscription,
    Token,
    Version
)

# Имя тестовой базы данных
DATABASE_NAME = 'test_db'

@pytest.fixture(scope='module')
def db():
    """
    Фикстура для настройки тестовой базы данных.

    :yield: Объект Database для тестовой базы данных.
    """
    test_db = Database(DATABASE_NAME)
    test_db._ensure_database()
    
    with test_db as connection:
        yield connection
    
    test_db.drop_db(DATABASE_NAME)

@pytest.fixture(autouse=True)
def setup_and_teardown(db):
    """
    Фикстура для создания и очистки таблиц перед каждым тестом.

    :param db: Объект Database для подключения к базе данных.
    """
    Application.create_table(db)
    Modification.create_table(db)
    Users.create_table(db)
    Purchase.create_table(db)
    Checks.create_table(db)
    HWID.create_table(db)
    Operation.create_table(db)
    Subscription.create_table(db)
    Token.create_table(db)
    Version.create_table(db)

    Users.create_many_to_many_tables(db)

    yield
    
    # Удаление данных из всех таблиц в правильной последовательности
    tables = [
        'checks', 'purchase', 'subscription', 'token', 'operation', 
        'hwid', 'version', 'users_modification', 'modification', 
        'users', 'application'
    ]
    for table in tables:
        db.delete_all_data(table)

def test_application_insert(db):
    """
    Тест вставки и получения данных для модели Application.
    """
    app = Application(app_name="Test Application")
    app.save(db)

    apps = Application.get_all(db)
    assert len(apps) == 1
    assert apps[0].app_name == "Test Application"

def test_users_insert(db):
    """
    Тест вставки и получения данных для модели Users.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)

    users = Users.get_all(db)
    assert len(users) == 1
    assert users[0].full_name == "John Doe"

def test_modification_insert(db):
    """
    Тест вставки и получения данных для модели Modification.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    mod = Modification(
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)

    mods = Modification.get_all(db)
    assert len(mods) == 1
    assert mods[0].mod_name == "Test Modification"

def test_purchase_insert(db):
    """
    Тест вставки и получения данных для модели Purchase.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    mod = Modification(
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)
    mod_id = mod.mod_id

    purchase = Purchase(
        user_id=user_id,
        mod_id=mod_id,
        purchase_date=datetime.now().date()
    )
    purchase.save(db)

    purchases = Purchase.get_all(db)
    assert len(purchases) == 1
    assert purchases[0].user_id == user_id

def test_checks_insert(db):
    """
    Тест вставки и получения данных для модели Checks.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    mod = Modification(
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)
    mod_id = mod.mod_id

    purchase = Purchase(
        user_id=user_id,
        mod_id=mod_id,
        purchase_date=datetime.now().date()
    )
    purchase.save(db)
    purchase_id = purchase.purchase_id

    checks = Checks(
        purchase_id=purchase_id,
        amount=99.99,
        payment_method="Credit Card"
    )
    checks.save(db)

    all_checks = Checks.get_all(db)
    assert len(all_checks) == 1
    assert float(all_checks[0].amount) == 99.99

def test_hwid_insert(db):
    """
    Тест вставки и получения данных для модели HWID.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    hwid = HWID(
        user_id=user_id,
        processor="Intel",
        videocard="NVIDIA",
        os_version="Windows 10",
        os_type="64-bit",
        disks="1TB SSD",
        network_card="Intel Ethernet"
    )
    hwid.save(db)

    hwids = HWID.get_all(db)
    assert len(hwids) == 1
    assert hwids[0].processor == "Intel"

def test_operation_insert(db):
    """
    Тест вставки и получения данных для модели Operation.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    operation = Operation(
        user_id=user_id,
        operation_type="LOGIN",
        operation_date=datetime.now()
    )
    operation.save(db)

    operations = Operation.get_all(db)
    assert len(operations) == 1
    assert operations[0].operation_type == "LOGIN"

def test_subscription_insert(db):
    """
    Тест вставки и получения данных для модели Subscription.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    mod = Modification(
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)
    mod_id = mod.mod_id

    subscription = Subscription(
        user_id=user_id,
        mod_id=mod_id,
        subscription_time=datetime.now()
    )
    subscription.save(db)

    subscriptions = Subscription.get_all(db)
    assert len(subscriptions) == 1
    assert subscriptions[0].user_id == user_id

def test_token_insert(db):
    """
    Тест вставки и получения данных для модели Token.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    user = Users(
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id

    hwid = HWID(
        user_id=user_id,
        processor="Intel",
        videocard="NVIDIA",
        os_version="Windows 10",
        os_type="64-bit",
        disks="1TB SSD",
        network_card="Intel Ethernet"
    )
    hwid.save(db)
    hwid_id = hwid.hwid_id

    token = Token(
        user_id=user_id,
        hwid_id=hwid_id,
        last_login=datetime.now()
    )
    token.save(db)

    tokens = Token.get_all(db)
    assert len(tokens) == 1
    assert tokens[0].user_id == user.user_id

def test_version_insert(db):
    """
    Тест вставки и получения данных для модели Version.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    mod = Modification(
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)
    mod_id = mod.mod_id

    version = Version(
        mod_id=mod_id,
        version_number=1,
        version_name="v1.0",
        version_description="Initial Release",
        version_link="http://example.com/download"
    )
    version.save(db)

    versions = Version.get_all(db)
    assert len(versions) == 1
    assert versions[0].version_name == "v1.0"

def test_many_to_many_insert(db):
    """
    Тест вставки и получения данных для таблицы many-to-many между Users и Modification.
    """
    app = Application(app_name="Test Application")
    app.save(db)
    app_id = app.app_id

    mod = Modification(
        mod_id="1",
        mod_name="Test Modification",
        mod_desc="A test modification.",
        app_id=app_id
    )
    mod.save(db)
    mod_id = mod.mod_id

    user = Users(
        user_id="1",
        full_name="John Doe",
        email="john.doe@example.com",
        password="password",
        registration_date=datetime.now().date(),
        app_availability=app_id
    )
    user.save(db)
    user_id = user.user_id
    
    with db.get_cursor() as cursor:
        cursor.execute(
            f"INSERT INTO users_modification (user_id, mod_id) VALUES ({user_id}, {mod_id})"
        )
    
    with db.get_cursor() as cursor:
        cursor.execute("SELECT * FROM users_modification")
        mm_records = cursor.fetchall()
        assert len(mm_records) == 1
        assert mm_records[0][0] == user_id
        assert mm_records[0][1] == mod_id

def test_generate_data(db):
    """
    Тест генерации и вставки данных для всех моделей.
    """
    apps = list(generate_application_data(1))
    for app in apps:
        app.save(db)
    app_ids = [app.app_id for app in Application.get_all(db)]

    users = list(generate_user_data(1, app_ids))
    for user in users:
        user.app_availability = app_ids[0]
        user.save(db)
    user_ids = [user.user_id for user in Users.get_all(db)]

    mods = list(generate_modification_data(1, app_ids))
    for mod in mods:
        mod.save(db)
    mod_ids = [mod.mod_id for mod in Modification.get_all(db)]

    purchases = list(generate_purchase_data(1, user_ids, mod_ids))
    for purchase in purchases:
        purchase.save(db)
    purchase_ids = [purchase.purchase_id for purchase in Purchase.get_all(db)]

    checks = list(generate_check_data(1, purchase_ids))
    for chk in checks:
        chk.save(db)

    hwids = list(generate_hwid_data(1, user_ids))
    for hw in hwids:
        hw.save(db)
    hwid_ids = [hw.hwid_id for hw in HWID.get_all(db)]

    operations = list(generate_operation_data(1, user_ids))
    for operation in operations:
        operation.save(db)

    subscriptions = list(generate_subscription_data(1, user_ids, mod_ids))
    for subscription in subscriptions:
        subscription.save(db)
    
    tokens = list(generate_token_data(1, user_ids, hwid_ids))
    for token in tokens:
        token.save(db)

    versions = list(generate_version_data(1, mod_ids))
    for version in versions:
        version.save(db)

    assert len(Application.get_all(db)) == 1
    assert len(Users.get_all(db)) == 1
    assert len(Modification.get_all(db)) == 1
    assert len(Purchase.get_all(db)) == 1
    assert len(Checks.get_all(db)) == 1
    assert len(HWID.get_all(db)) == 1
    assert len(Operation.get_all(db)) == 1
    assert len(Subscription.get_all(db)) == 1
    assert len(Token.get_all(db)) == 1
Файл tests/__init__.py:


